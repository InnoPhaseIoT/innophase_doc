<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Create Tasks (Threads) &mdash; InnoPhase 1.0.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=8d563738"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js "></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="../_static/js/custom.js" defer></script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            InnoPhase
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Create Tasks (Threads)</a></li>
<li><a class="reference internal" href="#soft-timers">Soft Timers</a></li>
<li><a class="reference internal" href="#semaphores">Semaphores</a></li>
<li><a class="reference internal" href="#work-queue">Work Queue</a></li>
<li><a class="reference internal" href="#wait-queue">Wait Queue</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">InnoPhase</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Create Tasks (Threads)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/9. Porting Guide/InnoOS to FreeRTOS.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>This porting guide describes the procedure to port from InnoOS to
FreeRTOS for multiple generic scenarios.</p>
<section id="create-tasks-threads">
<h1>Create Tasks (Threads)<a class="headerlink" href="#create-tasks-threads" title="Link to this heading"></a></h1>
<p><strong>Note</strong>: Argument order differs between os_create_thread()and
xTaskCreate()</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">Table 1: Create tasks (threads)</span><a class="headerlink" href="#id1" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p><strong>FreeRTOS</strong></p></th>
<th class="head"><p><strong>InnoOS</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BaseType_t
xTaskCreate(TaskFunction_t
pvTaskCode, const char * const
pcName, configSTACK_DEPTH_TYPE
usStackDepth, void
*pvParameters, UBaseType_t
uxPriority, TaskHandle_t
*pxCreatedTask);</p></td>
<td><p>struct os_thread
*os_create_thread(const char
*name, os_entrypoint_t entry,
os_threadarg_t arg, uint32_t
flags, size_t stacksz);</p></td>
</tr>
<tr class="row-odd"><td><p>static void task(void *arg)</p>
<p>{</p>
<p>int cnt = 0;</p>
<p>for(;;) {</p>
<p>printf(“Count %d\n”, cnt++);</p>
<p>vTaskDelay(1000,</p>
<p>portTICK_PERIOD_MS);</p>
<p>}</p>
<p>}</p>
<p>int main(void)</p>
<p>{</p>
<p>xTaskCreate(</p>
<p>task,</p>
<p>“task”,</p>
<p>1024,</p>
<p>NULL,</p>
<p>1,</p>
<p>NULL);</p>
<p>return 0;</p>
<p>}</p>
</td>
<td><p>static void * task(void *arg)</p>
<p>{</p>
<p>int cnt = 0;</p>
<p>for (;;) {</p>
<p>os_printf(“Count %d\n”, cnt++);</p>
<p>os_sleep_us(SYSTIME_SEC(1),</p>
<p>OS_TIMEOUT_WAKEUP);</p>
<p>}</p>
<p>return NULL;</p>
<p>}</p>
<p>int main(void)</p>
<p>{</p>
<p>os_create_thread(</p>
<p>“task”,</p>
<p>task,</p>
<p>NULL,</p>
<p>1,</p>
<p>1024);</p>
<p>return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Note</strong>: The stack size is represented as number of words (4 byte) in
FreeRTOS and number of bytes in InnOS.</p>
<p>Message Queues</p>
<p>In InnoOS, every thread gets a message queue at os_create_thread().
Hence, the message queues are not created separately. The message queues
have no maximum number of items, and the items can be of different
sizes.</p>
<p>Message type is used to differentiate between messages. The sender
specifies to which thread the message should be sent. The receiver does
not specify the queue, as it receives from its own thread queue. The
receiver has no reception timeout, but there is a flag which decides if
the call should wait or return immediately if there is no message in the
reception queue for the moment.</p>
<p>It is also possible to use os_recvmsg_type to wait for a specific
message type.</p>
<p>Following is an example with a Tx task sending messages to an Rx task:</p>
<p><strong>InnoOS</strong></p>
<table class="docutils align-default" id="id2">
<caption><span class="caption-text">Table 2: Semaphore – differences</span><a class="headerlink" href="#id2" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>#define MSG_TYPE 100</p>
<p>struct os_thread *thread_rx;</p>
<p>struct os_thread *thread_tx;</p>
<p>struct my_msg {</p>
<p>struct os_msg msg;</p>
<p>int data;</p>
<p>};</p>
<p>static void * tx(void *arg)</p>
<p>{</p>
<p>for (;;) {</p>
<p>struct my_msg *msg = (struct my_msg *)os_msg_alloc(MSG_TYPE, sizeof
*msg);</p>
<p>msg-&gt;data = 0xaddababe;</p>
<p>os_sendmsg(thread_rx, &amp;msg-&gt;msg);</p>
<p>os_sleep_us(SYSTIME_SEC(1), OS_TIMEOUT_WAKEUP);</p>
<p>}</p>
<p>return NULL;</p>
<p>}</p>
<p>static void * rx(void *arg)</p>
<p>{</p>
<p>for (;;) {</p>
<p>struct my_msg *rec = (struct my_msg *)os_recvmsg(false);</p>
<p>os_printf(“Received %x from %s\n”, rec-&gt;data,</p>
<p>os_thread_name(rec-&gt;msg.msg_sender));</p>
<p>os_msg_release((struct os_msg *)rec);</p>
<p>}</p>
<p>return NULL;</p>
<p>}</p>
<p>int main(void)</p>
<p>{</p>
<p>thread_tx = os_create_thread(“tx”, tx, NULL, 1, 1024);</p>
<p>thread_rx = os_create_thread(“rx”, rx, NULL, 1, 1024);</p>
<p>return 0;</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>In FreeRTOS, the message queue is created separately. Has a maximum size
and an element size. xQueueSend and xQueueReceive specify the message
queue, with specific timeouts on the duration for block in case of
failure.</p>
<p><strong>FreeRTOS</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#define Q_SIZE 5 /* number of items in queue */</p>
<p>#define I_SIZE sizeof(int) /* size of each item */</p>
<p>#define Q_TX_TO 500 /* timeout for send if queue is full */</p>
<p>#define Q_RX_TO 500 /* timeout for reception if queue is empty */</p>
<p>xQueueHandle msg_queue;</p>
<p>static void tx(void *arg)</p>
<p>{</p>
<p>int item = 0xaddababe;</p>
<p>for(;;) {</p>
<p>if (xQueueSend(msg_queue, &amp;item, Q_TX_TO))</p>
<p>printf(“Send ok\n”);</p>
<p>else</p>
<p>printf(“Send failed\n”);</p>
<p>vTaskDelay(1000, portTICK_PERIOD_MS);</p>
<p>}</p>
<p>}</p>
<p>static void rx(void *arg)</p>
<p>{</p>
<p>int item;</p>
<p>for(;;) {</p>
<p>if (xQueueReceive(msg_queue, &amp;item, Q_RX_TO)</p>
<p>printf(“Received %x\n”, item);</p>
<p>else</p>
<p>printf(“Reception failed\n”);</p>
<p>}</p>
<p>}</p>
<p>int main(void)</p>
<p>{</p>
<p>msg_queue = xQueueCreate(Q_SIZE, I_SIZE);</p>
<p>xTaskCreate(Rx, “Rx”, 1024, NULL, 1, NULL);</p>
<p>xTaskCreate(Tx, “Tx”, 1024, NULL, 1, NULL);</p>
<p>vTaskStartScheduler();</p>
<p>return 0;</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="soft-timers">
<h1>Soft Timers<a class="headerlink" href="#soft-timers" title="Link to this heading"></a></h1>
<p>In InnoOS, the timers are called callouts, and the APIs are prefixed
with callout_.</p>
<p>The preferred coding style is to use a struct including the timer
(callout) and the parameters needed. For example: cnt. In the callback
function, the pointer to the struct is captured via the container_of
macro.</p>
<p><strong>InnoOS</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#include &lt;kernel/os.h&gt;</p>
<p>#include &lt;kernel/callout.h&gt;</p>
<p>struct my_state {</p>
<p>struct callout timer;</p>
<p>uint32_t cnt;</p>
<p>} state;</p>
<p>static void __irq</p>
<p>timer_callback(struct callout *co)</p>
<p>{</p>
<p>struct my_state *state = container_of(co, struct my_state, timer);</p>
<p>state-&gt;cnt++;</p>
<p>os_printf(“cnt: %u\n”, state-&gt;cnt);</p>
<p>if (state-&gt;cnt &lt; 10)</p>
<p>/* Reschedule the timer */</p>
<p>callout_schedule(&amp;state-&gt;timer, SYSTIME_SEC(1));</p>
<p>else</p>
<p>os_printf(“Ready\n”);</p>
<p>}</p>
<p>int main(void)</p>
<p>{</p>
<p>callout_init(&amp;state.timer, timer_callback);</p>
<p>callout_schedule(&amp;state.timer, SYSTIME_SEC(1));</p>
<p>return 0;</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>In FreeRTOS, there is a built-in counter that determines the number of
times the counter has elapsed. There is also an auto-reload option where
the timer is automatically restarted. In this example we use it to
illustrate a difference between FreeRTOS and InnoOS.</p>
<p>For both FreeRTOS and InnoOS, the timer callback function will execute
in the timer interrupt service context, and no blocking calls must be
used. Preferably the work is handed over to another task/thread.</p>
<p><strong>FreeRTOS</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>static void timer_callback(TimerHandle_t timer)</p>
<p>{</p>
<p>uint32_t cnt = (uint32_t)pvTimerGetTimerID(timer);</p>
<p>cnt++;</p>
<p>printf(“cnt: %u\n”, cnt);</p>
<p>if (cnt &lt; 10)</p>
<p>/* timer is auto-reloaded */</p>
<p>vTimerSetTimerID(timer, (void*)cnt);</p>
<p>else {</p>
<p>xTimerStop(timer, 0);</p>
<p>printf(“Ready\n”);</p>
<p>}</p>
<p>}</p>
<p>int main(void)</p>
<p>{</p>
<p>TimerHandle_t timer;</p>
<p>timer = xTimerCreate(</p>
<p>“timer”,</p>
<p>1000/portTICK_PERIOD_MS,</p>
<p>pdTRUE, /* auto-reloaded */</p>
<p>(void*) 0,</p>
<p>timer_callback);</p>
<p>xTimerStart(timer,0);</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="semaphores">
<h1>Semaphores<a class="headerlink" href="#semaphores" title="Link to this heading"></a></h1>
<p>The differences between FreeRTOS and InnoOS when it comes to semaphores
are very small. lists the functions required.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>FreeRTOS</strong></p></th>
<th class="head"><p><strong>InnoOS</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>xSemaphoreHandle semaphore;</p></td>
<td><p>struct os_semaphore semaphore;</p></td>
</tr>
<tr class="row-odd"><td><p>semaphore =
xSemaphoreCreateCounting(1,
10);</p></td>
<td><p>os_sem_init(&amp;semaphore, 1);</p></td>
</tr>
<tr class="row-even"><td><p>semaphore =
xSemaphoreCreateMutex();</p></td>
<td><p>os_sem_init(&amp;semaphore, 1);</p></td>
</tr>
<tr class="row-odd"><td><p>xSemaphoreTake(semaphore,
timeout);</p></td>
<td><p>os_sem_wait_timeout(&amp;semaphore,
timeout);</p></td>
</tr>
<tr class="row-even"><td><p>xSemaphoreGive(semaphore);</p></td>
<td><p>os_sem_post(&amp;semaphore);</p></td>
</tr>
</tbody>
</table>
<p>InnoOS has the API os_sem_wait (&amp;semaphore), which is without timeout,
and which blocks until the semaphore is taken. This is the same behavior
which is achieved in FreeRTOS if:</p>
<ol class="arabic simple">
<li><p>INCLUDE_vTaskSuspend is set to ‘1’</p></li>
<li><p>Setting the timeout in xSemaphoreTake to portMAX_DELAY.</p></li>
</ol>
<p>xSemaphoreTake() as well as os_sem_wait() and os_sem_wait_timeout() must
not be used in interrupt context.</p>
</section>
<section id="work-queue">
<h1>Work Queue<a class="headerlink" href="#work-queue" title="Link to this heading"></a></h1>
<p>Work queues are used to schedule functions to run in a specific thread
context. Most commonly used to defer work from an interrupt handler that
needs to run quickly to another function that may do the more heavy
processing involved in serving the interrupt.</p>
<p>But FreeRTOS doesn’t have built support for Work Queue. However, this
can be easily implemented using a thread and a message queue.</p>
</section>
<section id="wait-queue">
<h1>Wait Queue<a class="headerlink" href="#wait-queue" title="Link to this heading"></a></h1>
<p>Wait queue is used for a task/thread to wait for an event.</p>
<p>But FreeRTOS doesn’t have built-in support for wait queue. However, this
can be easily implemented using semaphores and message queue.</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023 InnoPhase IoT, Inc. | All Rights Reserved | Proprietary &amp; Confidential.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>