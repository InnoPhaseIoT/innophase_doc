<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Low Power UART &mdash; InnoPhase 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="mDNS" href="Example_using_mDNS.html" />
    <link rel="prev" title="IFTTT" href="Example_using_IFTTT.html" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js "></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="../../_static/js/custom.js" defer></script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            InnoPhase
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Getting%20Started/Getting%20Started%20-%20Landing%20Page.html">Getting Started</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware%20Reference/Hardware-Reference.html">Hardware-Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Porting%20Guide/Porting-Guide.html">Porting-Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Disclaimers/Disclaimers.html">Disclaimer</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Appendix/Appendix-Landing_Page.html">Appendix</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Support/Support.html">Support</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Software%20Reference/Software_Reference_Landing_Page.html">Software Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Development%20Environments/Development%20Environments%20-%20Landing%20Page.html">Development Environments</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Tools/Tools-landing%20page.html">Tools</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../Applications%20-%20Landing%20Page.html">Applications</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../Applications%20-%20Landing%20Page.html#apps">Apps</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../Applications%20-%20Landing%20Page.html#examples">Examples</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="Example_for_Analog_to_Digital_Converter.html">Analog to Digital Converter (ADC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_Audio_over_I2S.html">Audio Over I2S</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_BLE_WiFi_Bridge.html">BLE WiFi Bridge</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_Crash_handling.html">Crash Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_I2C.html">I2C</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_LPScan.html">LPS Scan</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_MQTT.html">MQTT</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_Pulse_Width_Modulation.html">Pulse Width Modulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_Radio_and_Module_Parameters.html">Radio and Module Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_Secure_Files.html">Secure Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_Socket_Wakeup.html">Socket Wakeup</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_Software_SPI_Master.html">Software SPI Master</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_using_Chip_Monitor.html">Chip Monitor</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_using_Filesystem.html">Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_using_GPIO.html">GPIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_using_SNTP.html">SNTP</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_using_WiFi.html">WIFI</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_for_WiFi_Power_Management.html">WiFi Power Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_BLE_5_0.html">BLE 5.0</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_BLE_Beacons.html">BLE Beacon</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_Custom_ATCMDLIB.html">Custom ATCMDLIB</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_HTTP_Client.html">HTTP Client</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_IFTTT.html">IFTTT</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Low Power UART</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#basic-usage-of-uart">Basic Usage of UART</a></li>
<li class="toctree-l4"><a class="reference internal" href="#opening-the-serial-port">Opening the Serial Port</a></li>
<li class="toctree-l4"><a class="reference internal" href="#closing-the-serial-port">Closing the Serial Port</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transmitting-a-single-character">Transmitting a Single Character</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transmitting-a-string">Transmitting a String</a></li>
<li class="toctree-l4"><a class="reference internal" href="#receiving-blocking">Receiving (Blocking)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#receiving-blocking-with-timeout">Receiving (Blocking with Timeout)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#register-event-callback-called-when-talaria-two-wakes-from-sleep">Register Event Callback (called when Talaria TWO wakes from sleep)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#register-callback-called-when-special-character-is-received">Register Callback (called when special character is received)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recommended-protocol-for-2-wire-uart">Recommended Protocol for 2-wire UART</a></li>
<li class="toctree-l4"><a class="reference internal" href="#power-on">Power-ON</a></li>
<li class="toctree-l4"><a class="reference internal" href="#uart-apis">UART APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#uart-rx">UART-RX</a></li>
<li class="toctree-l4"><a class="reference internal" href="#code-walkthrough">Code Walkthrough</a></li>
<li class="toctree-l4"><a class="reference internal" href="#running-the-application">Running the Application</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expected-output">Expected Output</a></li>
<li class="toctree-l4"><a class="reference internal" href="#uart-tx">UART-TX</a></li>
<li class="toctree-l4"><a class="reference internal" href="#code-walkthrough-1">Code Walkthrough</a></li>
<li class="toctree-l4"><a class="reference internal" href="#running-the-application-1">Running the Application</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expected-output-1">Expected Output</a></li>
<li class="toctree-l4"><a class="reference internal" href="#uart-suspend-wakeup">UART Suspend/Wakeup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#code-walkthrough-2">Code Walkthrough</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-connection">Hardware Connection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#running-the-application-2">Running the Application</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expected-output-2">Expected Output</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_mDNS.html">mDNS</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_Provisioning.html">Provisioning</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_Provisioning.html#scan-data">Scan Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_Provisioning.html#configuration-data-format">Configuration Data Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_Provisioning.html#service">Service</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_Provisioning.html#characteristics">Characteristics</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_Provisioning.html#application-flow">Application Flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_Provisioning.html#sample-code-walkthrough">Sample Code Walkthrough</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_Provisioning.html#write-the-provisioning-file-into-talaria-two-filesystem">Write the Provisioning File into Talaria TWO Filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_Provisioning.html#programming-talaria-two-board-with-elf">Programming Talaria TWO board with ELF</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_Provisioning.html#running-the-application-using-android-or-ios-app">Running the Application using Android or iOS App</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_Unassociated_Mode.html">Unassociated Mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_Watchdog_Timer.html">Watchlog Timer</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_WCM_Multi_AP.html">WCM Multi AP</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example_using_Websock_Client.html">Websock Client</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Regulatory%20Notices/Regulatory%20Notices.html">FCC/ISED Regulatory Notices</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Security/Security%20-%20Landing%20Page.html">Security</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">InnoPhase</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../Applications%20-%20Landing%20Page.html">Applications</a></li>
      <li class="breadcrumb-item active">Low Power UART</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/Applications/2. Examples/Example_using_Low_Power_UART.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="low-power-uart">
<h1>Low Power UART<a class="headerlink" href="#low-power-uart" title="Permalink to this heading"></a></h1>
<p>The Talaria TWO device contains one high performance UART which can
handle bitrates up to 2.4Mbps. This document describes using the UART
with the help of UART APIs provided as part of the SDK.</p>
<p>Current scope of this document is limited to 2-wire UART with software
flow control.</p>
<p><a class="reference internal" href="../../_images/image110.png"><img alt="Graphical user interface, diagram, application Description automatically generated" src="../../_images/image110.png" style="width: 6.69291in; height: 3.80479in;" /></a></p>
<p>Figure 1: Talaria TWO device and HOST device serial communication
diagram</p>
<p>The following sample application code and script are included with this
application note:</p>
<table class="docutils align-default" id="id7">
<caption><span class="caption-text">Table 1: List of files included in the application note</span><a class="headerlink" href="#id7" title="Permalink to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p><strong>File</strong></p></th>
<th class="head"><p><strong>Description</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uart_tx.c</p></td>
<td><p>Sample Talaria TWO application describing the procedure
to send data on serial port using UART</p></td>
</tr>
<tr class="row-odd"><td><p>uart_rx.c</p></td>
<td><p>Sample Talaria TWO application describing the procedure
to read data on serial port using UART</p></td>
</tr>
<tr class="row-even"><td><p>uar
t_wakeup.c</p></td>
<td><p>Sample Talaria TWO application describing sleep/wakeup
procedure</p></td>
</tr>
<tr class="row-odd"><td><p>uart
_wakeup.py</p></td>
<td><p>Sample HOST side implementation to wake Talaria TWO
from sleep</p></td>
</tr>
</tbody>
</table>
<section id="basic-usage-of-uart">
<h2>Basic Usage of UART<a class="headerlink" href="#basic-usage-of-uart" title="Permalink to this heading"></a></h2>
<p>This section provides a quick introduction to the UART APIs and
describes communication with the host. For a comprehensive description
of all the APIs, refer to section 7.</p>
</section>
<section id="opening-the-serial-port">
<h2>Opening the Serial Port<a class="headerlink" href="#opening-the-serial-port" title="Permalink to this heading"></a></h2>
<p>Before opening a serial port, a handler must first be allocated.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>struct uart *handle;</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Once the UART handler is available, serial port can be opened using two
different functions:</p>
<ol class="arabic simple">
<li><p>uart_open – Opens serial port using default PINs and configured baud
rate.</p></li>
</ol>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>handle = uart_open(baudrate);</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li><p>uart_open_ex – Opens the serial port using the configured baud rate,
TXD, and RXD PINs.</p></li>
</ol>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#define TXD_PIN 1</p>
<p>#define RXD_PIN 2</p>
<p>…</p>
<p>int baudrate = 115200;</p>
<p>handle = uart_open_ex(baudrate, TXD_PIN, RXD_PIN, 0);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>Here, we configure the UART at a baud rate of 115200, GPIO1 as the
TXD pin, and GPIO2 as the RXD pin.</p>
</div></blockquote>
</section>
<section id="closing-the-serial-port">
<h2>Closing the Serial Port<a class="headerlink" href="#closing-the-serial-port" title="Permalink to this heading"></a></h2>
<p>uart_close is used to close the serial port.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>uart_close(handle);</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="transmitting-a-single-character">
<h2>Transmitting a Single Character<a class="headerlink" href="#transmitting-a-single-character" title="Permalink to this heading"></a></h2>
<p>uart_putchar is used to transmit a single character.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>char c = ‘z’;</p>
<p>…</p>
<p>uart_putchar(handle, c);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="transmitting-a-string">
<h2>Transmitting a String<a class="headerlink" href="#transmitting-a-string" title="Permalink to this heading"></a></h2>
<p>uart_puts is used to transmit a string.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>const char *message = ”Hello”;</p>
<p>…</p>
<p>uart_puts(handle, message);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="receiving-blocking">
<h2>Receiving (Blocking)<a class="headerlink" href="#receiving-blocking" title="Permalink to this heading"></a></h2>
<p>uart_getchar is used to read a character from the serial port. This
function call blocks until a byte is read.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>int c = uart_getchar(handle);</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="receiving-blocking-with-timeout">
<h2>Receiving (Blocking with Timeout)<a class="headerlink" href="#receiving-blocking-with-timeout" title="Permalink to this heading"></a></h2>
<p>uart_getchar_tmo is used to read a character from the serial port with a
timeout. This function call blocks until a byte is read or it times out.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>int c = uart_getchar_tmo(h, 1000000); //1s sec timeout</p>
<p>if (c == -1) //uart_getchar_tmo returns -1 on timeout</p>
<p>break;</p>
<p>else</p>
<p>os_printf(“%d_”, c);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="register-event-callback-called-when-talaria-two-wakes-from-sleep">
<h2>Register Event Callback (called when Talaria TWO wakes from sleep)<a class="headerlink" href="#register-event-callback-called-when-talaria-two-wakes-from-sleep" title="Permalink to this heading"></a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>static void __irq</p>
<p>handle_event(struct uart *u, enum uart_event type, void *priv)</p>
<p>{</p>
<p>//do stuff here</p>
<p>}</p>
<p>…</p>
<p>int main()</p>
<p>{</p>
<p>…</p>
<p>uart_set_event_callback(handle, handle_event, NULL);</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="register-callback-called-when-special-character-is-received">
<h2>Register Callback (called when special character is received)<a class="headerlink" href="#register-callback-called-when-special-character-is-received" title="Permalink to this heading"></a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>const char special = ‘z’;</p>
<p>…</p>
<p>static void uart_cb(void)</p>
<p>{</p>
<p>//do stuff here</p>
<p>}</p>
<p>…</p>
<p>int main()</p>
<p>{</p>
<p>uart_set_callback(handle, uart_cb, special);</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="recommended-protocol-for-2-wire-uart">
<h2>Recommended Protocol for 2-wire UART<a class="headerlink" href="#recommended-protocol-for-2-wire-uart" title="Permalink to this heading"></a></h2>
<p>Since 2-wire UART has no hardware flow control, a software protocol is
recommended in this section.</p>
</section>
<section id="power-on">
<h2>Power-ON<a class="headerlink" href="#power-on" title="Permalink to this heading"></a></h2>
<ol class="arabic simple">
<li><p>After powering ON Talaria TWO, UART initialization is completed with
required baud rate.</p></li>
<li><p>Talaria TWO then sends a known byte pattern to the host indicating
the readiness for UART transactions as illustrated in Figure 2.</p></li>
</ol>
<blockquote>
<div><p><a class="reference internal" href="../../_images/image23.png"><img alt="image1" src="../../_images/image23.png" style="width: 6.29921in; height: 2.43161in;" /></a></p>
</div></blockquote>
<p>Figure 2: Recommended Talaria TWO protocol for power-ON case</p>
</section>
<section id="uart-apis">
<h2>UART APIs<a class="headerlink" href="#uart-apis" title="Permalink to this heading"></a></h2>
<ol class="arabic simple">
<li><p>uart_open – Opens UART port.</p></li>
<li><p>uart_close – Closes UART port.</p></li>
<li><p>uart_getchar - Reads the next character from UART. If no character
is available, the function will block the calling thread until a
character arrives in UART.</p></li>
<li><p>uart_getchar_tmo – Reads the next character from the UART. If no
character is available, the function will block the calling thread
until either timeout occurs or a character arrives in UART.</p></li>
<li><p>uart_putchar – Write one character to UART.</p></li>
<li><p>uart_puts - Write a string to UART.</p></li>
<li><p>uart_flush – Flushes the output buffer.</p></li>
<li><p>uart_open_ex – Opens UART port with extended parameters.</p></li>
<li><p>uart_set_event_callback – Enables callback on events described by
the enum uart_event.</p></li>
<li><p>uart_set_callback – Enables callback, when a certain character is
entering the UART. This callback is executed in interrupt context.</p></li>
<li><p>uart_suspend_enable – Enables sleep mode.</p></li>
<li><p>os_gpio_request – Allocates and sets up PINs as GPIO.</p></li>
<li><p>os_gpio_set_output – Sets up GPIO PINs for output.</p></li>
<li><p>os_gpio_set_pin – Sets the specified GPIO PINs.</p></li>
<li><p>os_gpio_clr_pin – Clears the specified GPIO PINs.</p></li>
<li><p>uart_getchar_tmo – Reads one character from the serial port, with
timeout.</p></li>
<li><p>uart_putchar – Writes one character to the serial port.</p></li>
</ol>
</section>
<section id="uart-rx">
<h2>UART-RX<a class="headerlink" href="#uart-rx" title="Permalink to this heading"></a></h2>
</section>
<section id="code-walkthrough">
<h2>Code Walkthrough<a class="headerlink" href="#code-walkthrough" title="Permalink to this heading"></a></h2>
<p>uart_rx.c is used to read data on serial port using UART. This receives
the character sent from the host device to Talaria TWO through the UART.
Data will be printed on the console which can be used to verify the
working of the application.</p>
<p>struct uart is an opaque object representing the UART. This function
will initialize and allocate buffer space for the UART functions.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>struct uart *handle;</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>The function will return a pointer to an opaque object which is used as
a handle in subsequent calls to the UART functions. It opens the serial
port using baud rate 921600.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>handle = uart_open(921600);</p>
<p>if (handle == NULL)</p>
<p>return 1;</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>uart_puts() function writes the null terminated string pointed to by str
to the serial port. The terminating null byte (’\0’) will not be
written.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>int c = uart_getchar_tmo(handle, 1000000);</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>uart_getchar_tmo() function reads the next character from the serial
port. If no character is available, the function will block the calling
thread with timeout. Here, the timeout is 1 second.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>if(c !=-1)</p>
<p>os_printf(“%c”, c);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>uart_close() function closes the serial port and releases the memory
claimed by the uart_open() call. Any characters left in the output
buffers will be discarded.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>uart_close(handle);</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="running-the-application">
<h2>Running the Application<a class="headerlink" href="#running-the-application" title="Permalink to this heading"></a></h2>
<p><strong>Note</strong>: All applicable ELFs are available in the FreeRTOS SDK package
at: <em>freertos_sdk_x.y\examples\lp_uart\bin</em>.</p>
<p>x and y refer to the SDK release version. For example:
<em>freertos_sdk_2.5\doc</em>.</p>
<p>Program uart_rx.elf () using the Download tool:</p>
<ol class="arabic simple">
<li><p>Launch the Download tool provided with InnoPhase Talaria TWO SDK.</p></li>
<li><p>In the GUI window:</p>
<ol class="loweralpha simple">
<li><p>Boot Target: Select the appropriate EVK from the drop-down</p></li>
<li><p>ELF Input: Load the uart_rx.elf by clicking on Select ELF File.</p></li>
<li><p>Programming: Prog RAM or Prog Flash as per requirement.</p></li>
</ol>
</li>
</ol>
<p>For more details on using the Download tool, refer to the document:
UG_Download_Tool.pdf (path:
<em>freertos_sdk_x.y\pc_tools\Download_Tool\doc</em>).</p>
</section>
<section id="expected-output">
<h2>Expected Output<a class="headerlink" href="#expected-output" title="Permalink to this heading"></a></h2>
<p>uart_rx console output:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Y-BOOT 208ef13 2019-07-22 12:26:54 -0500 790da1-b-7</p>
<p>ROM yoda-h0-rom-16-0-gd5a8e586</p>
<p>FLASH:PNWWWAE</p>
<p>Build $Id: git-6e0f116 $</p>
<p>Flash detected. flash.hw.uuid: 39483937-3207-0083-00a1-ffffffffffff</p>
<p>$App:git-e8cee79</p>
<p>SDK Ver: FREERTOS_SDK_1.0</p>
<p>Lpuart Rx Demo App</p>
<p>Starting uart_rx_thread</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Open a minicom terminal with a baud rate of 921600, with no hardware
flow control and add the serial device.</p>
<p>Once the minicom starts, reset Talaria TWO which displays the output
string.</p>
<p><a class="reference internal" href="../../_images/image33.png"><img alt="image2" src="../../_images/image33.png" style="width: 1.10833in; height: 0.15833in;" /></a><a class="reference internal" href="../../_images/image43.png"><img alt="image3" src="../../_images/image43.png" style="width: 6.29921in; height: 1.98425in;" /></a></p>
<p>Figure 3: UART - RX Minicom Output</p>
</section>
<section id="uart-tx">
<h2>UART-TX<a class="headerlink" href="#uart-tx" title="Permalink to this heading"></a></h2>
</section>
<section id="code-walkthrough-1">
<span id="id1"></span><h2>Code Walkthrough<a class="headerlink" href="#code-walkthrough-1" title="Permalink to this heading"></a></h2>
<p>The uart_tx.c is used to send data on serial port using UART. This
transmits a string of data “Hello world” from Talaria TWO to host
through the UART.</p>
<p>The struct uart opaque object represents the UART. This function will
initialize and allocate buffer space for the UART functions.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>struct uart *handle;</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>The function will return a pointer to an opaque object that is used as a
handle in subsequent calls to the UART functions. It opens the serial
port using baud rate 921600.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>handle = uart_open(921600);</p>
<p>if (handle == NULL)</p>
<p>return 1;</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>This function will write the null terminated string pointed to by str to
the serial port. The terminating null byte (’\0’) will not be written.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>uart_puts(handle, “Hello World\n”);</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>uart_flush()calls the thread until all characters currently buffered for
output have been written to the serial port.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>uart_flush(handle);</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>The uart_close() function closes the serial port and releases the memory
claimed by the uart_open() call.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>uart_close(handle);</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="running-the-application-1">
<span id="id2"></span><h2>Running the Application<a class="headerlink" href="#running-the-application-1" title="Permalink to this heading"></a></h2>
<p>Program uart_tx.elf using the Download tool:</p>
<ol class="arabic simple">
<li><p>Launch the Download tool provided with InnoPhase Talaria TWO SDK.</p></li>
<li><p>In the GUI window:</p>
<ol class="loweralpha simple">
<li><p>Boot Target: Select the appropriate EVK from the drop-down</p></li>
<li><p>ELF Input: Load the uart_tx.elf by clicking on Select ELF File.</p></li>
<li><p>Programming: Prog RAM or Prog Flash as per requirement.</p></li>
</ol>
</li>
</ol>
</section>
<section id="expected-output-1">
<span id="id3"></span><h2>Expected Output<a class="headerlink" href="#expected-output-1" title="Permalink to this heading"></a></h2>
<p>uart_tx console output:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Y-BOOT 208ef13 2019-07-22 12:26:54 -0500 790da1-b-7</p>
<p>ROM yoda-h0-rom-16-0-gd5a8e586</p>
<p>FLASH:PNWWWAE</p>
<p>Build $Id: git-6e0f116 $</p>
<p>Flash detected. flash.hw.uuid: 39483937-3207-0083-00a1-ffffffffffff</p>
<p>$App:git-e8cee79</p>
<p>SDK Ver: FREERTOS_SDK_1.0</p>
<p>Lpuart Tx Demo App</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Open a minicom terminal with a baud rate of 921600, with no Hardware
flow control and add the serial device.</p>
<p>Once the minicom starts, reset the Talaria TWO device which displays the
output string.</p>
<p><a class="reference internal" href="../../_images/image33.png"><img alt="image4" src="../../_images/image33.png" style="width: 0.87932in; height: 0.14236in;" /></a><a class="reference internal" href="../../_images/image53.png"><img alt="Text Description automatically generated" src="../../_images/image53.png" style="width: 6.29921in; height: 2.07258in;" /></a></p>
<p>Figure 4: UART – TX Minicom Output</p>
</section>
<section id="uart-suspend-wakeup">
<h2>UART Suspend/Wakeup<a class="headerlink" href="#uart-suspend-wakeup" title="Permalink to this heading"></a></h2>
</section>
<section id="code-walkthrough-2">
<span id="id4"></span><h2>Code Walkthrough<a class="headerlink" href="#code-walkthrough-2" title="Permalink to this heading"></a></h2>
<p>uart_wakeup.c</p>
<p>The sample application uart_wakeup.c shows a basic implementation of
UART suspend/wakeup using UART_BREAK signal.</p>
<p>This section describes the state of the UART, whether the link is up or
down.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>enum uart_link_state {</p>
<p>UART_LINK_UP = 0,</p>
<p>UART_LINK_DOWN,</p>
<p>} link</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>handle_event() handles the UART events and checks if the type is
UART_EVENT_WAKEUP. If yes, then the uart_status will be set to UART_WAKE
until suspend state is enabled.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>static void __irq</p>
<p>handle_event(struct uart *h, enum uart_event type, void *priv)</p>
<p>{</p>
<p>if (type == UART_EVENT_WAKEUP)</p>
<p>{</p>
<p>pr_always(“UART_EVENT_WAKEUP\n”);</p>
<p>uart_status=UART_WAKE;</p>
<p>struct uart_wakeup_msg *msg</p>
<p>= (struct uart_wakeup_msg *)osal_alloc(sizeof(*msg));</p>
<p>msg-&gt;event = APP_MSG_AWAKE_UART;</p>
<p>xQueueSendFromISR(uart_event_queue, (void *)&amp;msg, NULL);</p>
<p>}</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>os_gpio_request() API requests the pins and configures the pin as GPIO,
os_gpio_set_output() API configures the GPIO pins as digital output
pins, os_gpio_clr_pin() is used to clear the specified GPIO pins,
os_gpio_set_pin() is used to set the GPIO high and os_gpio_clr_pin() is
used to set GPIO low.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>void app_main(void *arg)</p>
<p>{</p>
<p>uint32_t ulValue, recv_status;</p>
<p>struct uart_wakeup_msg *msg = NULL;</p>
<p>os_gpio_request(sig_pin);</p>
<p>os_gpio_set_output(sig_pin);</p>
<p>uart_suspend_enable(u);</p>
<p>while (1) {</p>
<p>os_gpio_set_pin(sig_pin);</p>
<p>/* blocking. */</p>
<p>recv_status</p>
<p>= xQueueReceive(uart_event_queue, &amp;ulValue, portMAX_DELAY);</p>
<p>os_gpio_clr_pin(sig_pin);</p>
<p>if (0 == recv_status)</p>
<p>continue;</p>
<p>msg = (struct uart_wakeup_msg *)ulValue;</p>
<p>if (msg-&gt;event == APP_MSG_AWAKE_UART) {</p>
<p>{</p>
<p>if(uart_status != UART_INACTIVE)</p>
<p>{</p>
<p>int c = uart_getchar_tmo(u, UART_TMO_CLR); // read and drop garbage
byte</p>
<p>rx_ready = true;</p>
<p>uart_putchar(u, ‘R’); // can be used for syncing</p>
<p>while(rx_ready)</p>
<p>{</p>
<p>c = uart_getchar_tmo(u, UART_TMO_FIRST_BYTE); //first byte may take a
while depending on when the event gets triggered</p>
<p>while(c!=-1)</p>
<p>{</p>
<p>/**</p>
<p>* We look for ‘*’ to signify end of message.</p>
<p>* Ideally the HOST and T2 would use an agreed upon protocol to
determine length and validity of packet from HOST</p>
<p>**/</p>
<p>if((char)c == ‘*’)</p>
<p>{</p>
<p>uart_putchar(u, ‘A’);</p>
<p>}</p>
<p>c = uart_getchar_tmo(u, UART_TMO_BYTE);</p>
<p>}</p>
<p>// process message here</p>
<p>// wait and check if HOST plans to send more packets</p>
<p>c = uart_getchar_tmo(u, UART_TMO_EXTENDED); //should catch the break</p>
<p>if(c == -1)</p>
<p>{</p>
<p>//no additional packet/s</p>
<p>rx_ready = false;</p>
<p>}</p>
<p>}</p>
<p>uart_putchar(u, ‘S’);</p>
<p>pr_always(“uart_suspend_enable\n”);</p>
<p>uart_suspend_enable(u);</p>
<p>uart_status=UART_INACTIVE;</p>
<p>}</p>
<p>}</p>
<p>osal_free(msg);</p>
<p>}</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>wcm_create()API from the Wi-Fi Connection Manager is used to connect to
a Wi-Fi network. Initially, the Wi-Fi network interface is created using
wcm_create().</p>
<p>wifi_connect_to_network()API, from components library, connects to the
Wi-Fi network using the AP credentials provided.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>/*Create a Wi-Fi network interface*/</p>
<p>wcm_handle = wcm_create(NULL);</p>
<p>/* Read the configuration and connect to desired network */</p>
<p>rval = wifi_connect_to_network(&amp;wcm_handle, WCM_CONN_WAIT_INFINITE,
&amp;wcm_connected);</p>
<p>if(rval &lt; 0) {</p>
<p>os_printf(”\nError: Unable to connect to network\n”);</p>
<p>return 0;</p>
<p>}</p>
<p>if(wcm_connected != true) {</p>
<p>os_printf(”\nCouldn’t Connect to network “);</p>
<p>wcm_disconnect(wcm_handle);</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>uart_wakeup_host.c</p>
<p>The sample application uart_wakeup_host.c shows implementation of a HOST
MCU which can wakeup Talaria TWO using UART.</p>
<p>A serial port with a baud rate of 115200 is opened using uart_open().</p>
<p><strong>Single Packet Test</strong>:</p>
<p>Single packet test prints the errors along with the 1000 packets.</p>
<p>Pins and GPIOs are used to emulate a long UART_BREAK signal. Here
uart_getchar_tmo() reads one character “R” from the serial port which
indicates Ready. If no character is available, the function will block
the calling thread until timeout occurs.</p>
<p>Host will again wait for Talaria TWO to echo back the last end sync
character which is the acknowledgement “A” packet.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>u = uart_open(115200);</p>
<p>int count = 0;</p>
<p>int errors = 0;</p>
<p>int packets = 1000;</p>
<p>char count_buffer[32];</p>
<p>bool retransmit = false;</p>
<p>os_printf(“Single packet test\n”);</p>
<p>while(count &lt; packets)</p>
<p>{</p>
<p>//Use pin ad GPIO to emulate a long UART_BREAK signal</p>
<p>int tx_pin = 1 &lt;&lt; TX_PIN;</p>
<p>os_gpio_set_mode(tx_pin, GPIO_MODE);</p>
<p>os_gpio_request(tx_pin);</p>
<p>os_gpio_set_output(tx_pin);</p>
<p>os_gpio_clr_pin(tx_pin);</p>
<p>vTaskDelay(1);</p>
<p>os_gpio_set_pin(tx_pin);</p>
<p>os_gpio_set_input(tx_pin);</p>
<p>os_gpio_set_mode(tx_pin, GPIO_FUNCTION_MODE);</p>
<p>os_gpio_free(tx_pin);</p>
<p>while(1)</p>
<p>{</p>
<p>//Wait for ready ‘r’ from T2</p>
<p>int sync = uart_getchar_tmo(u, 1000);</p>
<p>if(sync == -1)</p>
<p>{</p>
<p>break;</p>
<p>}</p>
<p>else if((char)sync == ‘R’)</p>
<p>{</p>
<p>if(retransmit)</p>
<p>{</p>
<p>errors++;</p>
<p>os_printf(“retransmitting!!!\n”);</p>
<p>}</p>
<p>memset(count_buffer, 0, 32);</p>
<p>sprintf(count_buffer, “count: %d\n”, count);</p>
<p>uart_write((void*)msg1, strlen(msg1));</p>
<p>uart_write((void*)msg2, strlen(msg2));</p>
<p>uart_write((void*)count_buffer, strlen(count_buffer));</p>
<p>uart_write((void*)msg4, strlen(msg4)); //send end sync char ‘*’</p>
<p>uart_flush(u);</p>
<p>//Wait for T2 to echo back the last end sync char ‘*’</p>
<p>sync = uart_getchar_tmo(u, 2000);</p>
<p>retransmit = true;</p>
<p>while(sync != -1)</p>
<p>{</p>
<p>if(sync == ‘A’)</p>
<p>{</p>
<p>retransmit = false;</p>
<p>count++;</p>
<p>break;</p>
<p>}</p>
<p>sync = uart_getchar_tmo(u, 2000);</p>
<p>}</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>if(!retransmit)</p>
<p>{</p>
<p>vTaskDelay(50);</p>
<p>}</p>
<p>}</p>
<p>os_printf(“%d errors to send %d packets\n”, errors, packets);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p><strong>Multiple Packet Test</strong>:</p>
<p>Multiple packet test prints the errors along with the 1000 packets.</p>
<p>PINs and GPIOs are used to emulate a long UART_BREAK signal. Here
uart_getchar_tmo() reads one character “R” from the serial port which
indicates Ready. If no character is available, the function will block
the calling thread until timeout occurs.</p>
<p>Host will again wait for Talaria TWO to echo back the last end sync
character which is the acknowledgement “A” packet.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>count = 0;</p>
<p>os_printf(“Multi packet test\n”);</p>
<p>while(count &lt; packets)</p>
<p>{</p>
<p>//Use pin ad GPIO to emulate a long UART_BREAK signal</p>
<p>int tx_pin = 1 &lt;&lt; TX_PIN;</p>
<p>os_gpio_set_mode(tx_pin, GPIO_MODE);</p>
<p>os_gpio_request(tx_pin);</p>
<p>os_gpio_set_output(tx_pin);</p>
<p>os_gpio_clr_pin(tx_pin);</p>
<p>vTaskDelay(1);</p>
<p>os_gpio_set_pin(tx_pin);</p>
<p>os_gpio_set_input(tx_pin);</p>
<p>os_gpio_set_mode(tx_pin, GPIO_FUNCTION_MODE);</p>
<p>os_gpio_free(tx_pin);</p>
<p>while(1)</p>
<p>{</p>
<p>//Wait for ready ‘r’ from T2</p>
<p>int sync = uart_getchar_tmo(u, 1000);</p>
<p>if(sync == -1)</p>
<p>{</p>
<p>break;</p>
<p>}</p>
<p>else if((char)sync == ‘R’)</p>
<p>{</p>
<p>if(retransmit)</p>
<p>{</p>
<p>errors++;</p>
<p>os_printf(“retransmitting!!!\n”);</p>
<p>}</p>
<p>memset(count_buffer, 0, 32);</p>
<p>sprintf(count_buffer, “count: %d\n”, count);</p>
<p>uart_write((void*)msg1, strlen(msg1));</p>
<p>uart_write((void*)msg2, strlen(msg2));</p>
<p>uart_write((void*)count_buffer, strlen(count_buffer));</p>
<p>uart_write((void*)msg4, strlen(msg4)); //send end sync char ‘*’</p>
<p>uart_flush(u);</p>
<p>//Wait for T2 to echo back the last end sync char ‘*’</p>
<p>sync = uart_getchar_tmo(u, 2000);</p>
<p>retransmit = true;</p>
<p>while(sync != -1)</p>
<p>{</p>
<p>if(sync == ‘A’)</p>
<p>{</p>
<p>retransmit = false;</p>
<p>count++;</p>
<p>break;</p>
<p>}</p>
<p>sync = uart_getchar_tmo(u, 2000); }</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Using PINs and GPIOs emulate a long UART_BREAK signal and send the
second packet before Talaria TWO UART goes into suspend state.
uart_flush() and uart_close() are used to empty the output buffers
before closing.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>vTaskDelay(5);</p>
<p>// send second packet before T2 UART goes into suspend</p>
<p>//Use pin ad GPIO to emulate a long UART_BREAK signal</p>
<p>tx_pin = 1 &lt;&lt; TX_PIN;</p>
<p>os_gpio_set_mode(tx_pin, GPIO_MODE);</p>
<p>os_gpio_request(tx_pin);</p>
<p>os_gpio_set_output(tx_pin);</p>
<p>os_gpio_clr_pin(tx_pin);</p>
<p>vTaskDelay(1);</p>
<p>os_gpio_set_pin(tx_pin);</p>
<p>os_gpio_set_input(tx_pin);</p>
<p>os_gpio_set_mode(tx_pin, GPIO_FUNCTION_MODE);</p>
<p>os_gpio_free(tx_pin);</p>
<p>memset(count_buffer, 0, 32);</p>
<p>sprintf(count_buffer, “count: %d\n”, count);</p>
<p>uart_write((void*)msg1, strlen(msg1));</p>
<p>uart_write((void*)msg2, strlen(msg2));</p>
<p>uart_write((void*)count_buffer, strlen(count_buffer));</p>
<p>uart_write((void*)msg4, strlen(msg4)); //send end sync char ‘*’</p>
<p>uart_flush(u);</p>
<p>//Wait for T2 to echo back the last end sync char ‘*’</p>
<p>sync = uart_getchar_tmo(u, 2000);</p>
<p>retransmit = true;</p>
<p>while(sync != -1)</p>
<p>{</p>
<p>if(sync == ‘A’)</p>
<p>{</p>
<p>retransmit = false;</p>
<p>count++;</p>
<p>break;</p>
<p>}</p>
<p>sync = uart_getchar_tmo(u, 2000);</p>
<p>}</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>if(!retransmit)</p>
<p>{</p>
<p>vTaskDelay(50);</p>
<p>}</p>
<p>}</p>
<p>os_printf(“%d errors to send %d packets\n”, errors, packets);</p>
<p>/* Make sure the output buffers are empty before closing. */</p>
<p>uart_flush(u);</p>
<p>uart_close(u);</p>
<p>return 0;</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="hardware-connection">
<h2>Hardware Connection<a class="headerlink" href="#hardware-connection" title="Permalink to this heading"></a></h2>
<p>Using two Talaria TWO boards and a logic analyzer make the connection
using the required wires and breadboard as shown in Figure 5.</p>
<p><a class="reference internal" href="../../_images/image62.png"><img alt="image5" src="../../_images/image62.png" style="width: 5.90551in; height: 2.46587in;" /></a></p>
<p>Figure 5: UART suspend/wakeup - hardware connection</p>
</section>
<section id="running-the-application-2">
<span id="id5"></span><h2>Running the Application<a class="headerlink" href="#running-the-application-2" title="Permalink to this heading"></a></h2>
<p>Program uart_wakeup_host.elf and uart_wakeup.elf onto Talaria TWO boards
using the Download tool:</p>
<ol class="arabic simple">
<li><p>Launch the Download Tool provided with InnoPhase Talaria TWO SDK.</p></li>
<li><p>In the GUI window:</p>
<ol class="loweralpha simple">
<li><p>Boot Target: Select the appropriate EVK from the drop-down</p></li>
<li><p>ELF Input: Load uart_wakeup_host.elf and uart_wakeup.elf by
clicking on Select ELF File.</p></li>
<li><p>AP Options: Pass the appropriate SSID and passphrase to connect to
an Access Point for uart_wakeup.elf.</p></li>
<li><p>Programming: Prog RAM or Prog Flash as per requirement.</p></li>
</ol>
</li>
</ol>
</section>
<section id="expected-output-2">
<span id="id6"></span><h2>Expected Output<a class="headerlink" href="#expected-output-2" title="Permalink to this heading"></a></h2>
<p>Once the hardware connection is complete as described in section 7.3.2,
flash Talaria TWO boards with uart_wakeup_host.elf and uart_wakeup.elf .
Simultaneously reset on Talaria TWO’s GUI or press the hard reset button
on Talaria TWO boards and observe the following console outputs:</p>
<p>uart_wakeup.elf:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Y-BOOT 208ef13 2019-07-22 12:26:54 -0500 790da1-b-7</p>
<p>ROM yoda-h0-rom-16-0-gd5a8e586</p>
<p>FLASH:PNWWWWWWWAE</p>
<p>Build $Id: git-6e0f116 $</p>
<p>Flash detected. flash.hw.uuid: 39483937-3207-0083-00a1-ffffffffffff</p>
<p>Bootargs: np_conf_path=/data/nprofile.json ssid=tplinkc6_iop
passphrase=InnoQA2023$</p>
<p>Sleep wakeup Test</p>
<p>$App:git-894dc59</p>
<p>SDK Ver: FREERTOS_SDK_1.0</p>
<p>UART Wakeup</p>
<p>addr e0:69:3a:00:15:b0</p>
<p>Connecting to added network : tplinkc6_iop</p>
<p>[0.868,199] CONNECT:10:27:f5:7d:e8:74 Channel:9 rssi:-27 dBm</p>
<p>wcm_notify_cb to App Layer - WCM_NOTIFY_MSG_LINK_UP</p>
<p>[1.071,828] MYIP 192.168.0.146</p>
<p>[1.071,877] IPv6 [fe80::e269:3aff:fe00:15b0]-link</p>
<p>wcm_notify_cb to App Layer - WCM_NOTIFY_MSG_CONNECTED</p>
<p>wcm_notify_cb to App Layer - WCM_NOTIFY_MSG_ADDRESS</p>
<p>Connected to added network : tplinkc6_iop</p>
<p>os_suspend_enable</p>
<p>os_suspend_enable</p>
<p>[46.813,497] UART_EVENT_WAKEUP</p>
<p>[46.825,104] uart_suspend_enable</p>
<p>[46.825,282] UART_EVENT_WAKEUP</p>
<p>[46.837,110] uart_suspend_enable</p>
<p>[46.837,287] UART_EVENT_WAKEUP</p>
<p>[46.849,113] uart_suspend_enable</p>
<p>[46.849,292] UART_EVENT_WAKEUP</p>
<p>[46.861,120] uart_suspend_enable</p>
<p>[46.861,297] UART_EVENT_WAKEUP</p>
<p>[46.873,123] uart_suspend_enable</p>
<p>[46.873,303] UART_EVENT_WAKEUP</p>
<p>[46.885,127] uart_suspend_enable</p>
<p>[46.885,308] UART_EVENT_WAKEUP</p>
<p>[46.897,131] uart_suspend_enable</p>
<p>[46.897,313] UART_EVENT_WAKEUP</p>
<p>[46.909,135] uart_suspend_enable</p>
<p>[46.909,318] UART_EVENT_WAKEUP</p>
<p>[46.921,139] uart_suspend_enable</p>
<p>[46.921,323] UART_EVENT_WAKEUP</p>
<p>[46.933,145] uart_suspend_enable</p>
<p>[46.933,328] UART_EVENT_WAKEUP</p>
<p>[46.945,148] uart_suspend_enable</p>
<p>[46.945,334] UART_EVENT_WAKEUP</p>
<p>[46.957,161] uart_suspend_enable</p>
<p>[46.957,339] UART_EVENT_WAKEUP</p>
<p>[46.969,164] uart_suspend_enable</p>
<p>[46.969,344] UART_EVENT_WAKEUP</p>
<p>[46.981,168] uart_suspend_enable</p>
<p>[46.981,349] UART_EVENT_WAKEUP</p>
<p>[46.993,172] uart_suspend_enable</p>
<p>[46.993,354] UART_EVENT_WAKEUP</p>
<p>[47.005,176] uart_suspend_enable</p>
<p>[47.005,359] UART_EVENT_WAKEUP</p>
<p>[47.017,182] uart_suspend_enable</p>
<p>[47.017,365] UART_EVENT_WAKEUP</p>
<p>[47.029,185] uart_suspend_enable</p>
<p>[47.029,370] UART_EVENT_WAKEUP</p>
<p>[47.041,189] uart_suspend_enable</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>uart_wakeup_host.elf:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Y-BOOT 208ef13 2019-07-22 12:26:54 -0500 790da1-b-7</p>
<p>ROM yoda-h0-rom-16-0-gd5a8e586</p>
<p>FLASH:PNWWWWAE</p>
<p>Build $Id: git-6e0f116 $</p>
<p>Flash detected. flash.hw.uuid: 39483937-3207-0083-00a1-ffffffffffff</p>
<p>Single packet test</p>
<p>0 errors to send 1000 packets</p>
<p>Multi packet test</p>
<p>0 errors to send 1000 packets</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Following output is observed on the logic analyzer:</p>
<div class="line-block">
<div class="line">The UART interface on Talaria TWO can be placed in suspend mode while
there is no UART activity between Talaria TWO and Host.</div>
<div class="line">To wake up Talaria TWO from sleep and re-enable the UART interface,
the Host needs to send the UART_BREAK signal for a minimum duration of
1ms.</div>
</div>
<p><a class="reference internal" href="../../_images/image72.png"><img alt="image6" src="../../_images/image72.png" style="width: 5.90551in; height: 2.12637in;" /></a></p>
<p>Figure 6: UART suspend/wakeup - Wakeup from UART_BREAK</p>
<p>uart_wakeup example follows the subsequent protocol:</p>
<ol class="arabic simple">
<li><p>HOST sends break.</p></li>
<li><p>Talaria TWO wakes up and takes UART out of SUSPEND. Talaria TWO sends
a byte ‘R’ to inform the Host that UART interface is ready.</p></li>
<li><p>Host (optionally) waits for ~1ms or ‘R’ and then sends data.</p></li>
<li><p>Talaria TWO receives the data.</p></li>
</ol>
<blockquote>
<div><p>Note: Talaria TWO performs error checking and lets the Host know if
re-transmit is required.</p>
</div></blockquote>
<ol class="loweralpha simple">
<li><p>Talaria TWO can determine whether the Host is done sending either by
a timeout or similar protocol.</p></li>
<li><p>Talaria TWO sends an acknowledgement byte ‘A’ after validating the
packet.</p></li>
<li><p>Talaria TWO optionally waits (~10 ms) for more incoming packets.</p></li>
</ol>
<ol class="arabic simple" start="5">
<li><p>Talaria TWO sends a byte ‘S’ to the Host to inform the Host that the
UART is entering SUSPEND state.</p></li>
</ol>
<p><a class="reference internal" href="../../_images/image82.png"><img alt="image7" src="../../_images/image82.png" style="width: 5.90551in; height: 2.15233in;" /></a></p>
<p>Figure 7: Wakeup from UART_BREAK and IPC communication with HOST</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Example_using_IFTTT.html" class="btn btn-neutral float-left" title="IFTTT" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Example_using_mDNS.html" class="btn btn-neutral float-right" title="mDNS" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023 InnoPhase IoT, Inc. | All Rights Reserved | Proprietary &amp; Confidential.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>