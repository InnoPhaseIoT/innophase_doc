<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction &mdash; InnoPhase 1.0.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Introduction" href="SSBL.html" />
    <link rel="prev" title="Introduction" href="Socket%20Wakeup.html" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js "></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="../_static/js/custom.js" defer></script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            InnoPhase
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Getting_Started_Landing_page.html">Getting Started</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Hardware-Reference.html">Hardware-Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Porting-Guide.html">Porting-Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Software_Reference/Prerequisites/libusbK_driver-Zadig.html">Software Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Development_Environments/Development_Environments.html">Development Environments</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Tools/Tools_Landing.html">Tools</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="Applications-Landing_Page.html">Applications</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#alarm">1.  Alarm</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#analog-to-digital-converter">2.  Analog to Digital Converter</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#audio-over-i2s">3.  Audio over I2S</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#ble-5-0">4.  BLE 5.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#ble-beacons">3.  BLE Beacons</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#ble-wi-fi-bridge">4.  BLE Wi-Fi Bridge</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#chip-monitor">5.  Chip Monitor</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#crash-handling">6.  Crash Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#custom-atcmdlib">6.  Custom ATCMDLIB</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#filesystem">7.  Filesystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#firmware-over-the-air-upgrade">8.  Firmware Over the Air Upgrade</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#gpio">9.  GPIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#host-interface-protocol">10. Host Interface Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#http-client">11. HTTP Client</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#i2c">12. I2C</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#ifttt">13. IFTTT</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#iot-aws">14. IoT AWS</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#iot-azure">15. IoT Azure</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#low-power-scan">16. Low Power Scan</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#low-power-uart">17. Low Power UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#mdns">18. mDNS</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#memory-management-and-error-handling">19.  Memory Management and Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#message-queues">20.  Message Queues</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#mqtt">21.  MQTT</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#provisioning">22.  Provisioning</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#pulse-width-modulation">23.  Pulse Width Modulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#radio-and-module-parameters">24. Radio and Module Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#secure-files">25. Secure Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#simple-network-time-protocol">26.  Simple Network Time Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#sleep-enable-disable">27.  Sleep Enable Disable</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#socket-wakeup">28. Socket Wakeup</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#software-spi-master">29. Software SPI Master</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="Applications-Landing_Page.html#spi-flash">30. SPI Flash</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#list-of-apis">List of APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-talaria-two-spi-flash">Using Talaria TWO SPI Flash</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#talaria-two-spi-flash-memory-layout">Talaria TWO SPI Flash Memory Layout</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sample-application-1-spiflash-sample1">Sample application 1: spiflash_sample1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sample-application-2-spiflash-sample2">Sample application 2: spiflash_sample2</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#ssbl">31. SSBL</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#thread-and-semaphores">32.  Thread and Semaphores</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#throughput-measurement">32.  Throughput Measurement</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#timers-and-callouts">33. Timers and Callouts</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#unassociated-mode">34. Unassociated Mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#using-wi-fi">35. Using Wi-Fi</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#watchdog-timer">36. Watchdog Timer</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#websocket-client">37. Websocket Client</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#wi-fi-connection-manager-multi-ap">38. Wi-Fi Connection Manager Multi-AP</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#wi-fi-power-management">39. Wi-Fi Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="Applications-Landing_Page.html#work-queues">40. Work Queues</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Regulatory%20Notices/Regulatory%20Notices.html">Regulatory Notice</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Security/Security%20-%20Landing%20Page.html">Security</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Backend%20Files%20-%20for%20cross%20referencing/Backend%20File%20Landing.html">Backend Files - for cross referencing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../about.html">About</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">InnoPhase</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="Applications-Landing_Page.html">Applications</a></li>
      <li class="breadcrumb-item active">Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Applications/SPI Flash.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h1>
<p>The Talaria TWO module has a 2MB SPI Flash for storing application and
user data. This application note describes using the SPI Flash APIs to
read, write and erase flash on Talaria TWO module.</p>
</section>
<section id="list-of-apis">
<h1>List of APIs<a class="headerlink" href="#list-of-apis" title="Permalink to this heading"></a></h1>
<ol class="arabic simple">
<li><p>spi_mem_device(): SPI memory device.</p></li>
<li><p>os_flash_get_spi_dev(): Gets SPI device pointer for flash.</p></li>
<li><p>spi_sector_erase(): Erases sector.</p></li>
<li><p>spi_mem_write(): Writes on a specific position in flash.</p></li>
<li><p>spi_mem_read(): Reads from a position in flash.</p></li>
</ol>
<p>For more details on APIs, refer:</p>
<p>T2-RM001-V25-Talaria_TWO_SDK_API_Reference_Guide.pdf</p>
<p>(path: <em>sdk_x.y\doc\reference_guides\api_reference_guide</em>).</p>
<p><strong>Note</strong>: x and y refer to the SDK release version. For example:
<em>sdk_2.4\doc</em>.</p>
</section>
<section id="using-talaria-two-spi-flash">
<h1>Using Talaria TWO SPI Flash<a class="headerlink" href="#using-talaria-two-spi-flash" title="Permalink to this heading"></a></h1>
<section id="talaria-two-spi-flash-memory-layout">
<h2>Talaria TWO SPI Flash Memory Layout<a class="headerlink" href="#talaria-two-spi-flash-memory-layout" title="Permalink to this heading"></a></h2>
<p>Figure 1 shows the default SPI Flash memory layout for the Talaria TWO.</p>
<p><a class="reference internal" href="../_images/image1.png"><img alt="image1" src="../_images/image1.png" style="width: 6.69291in; height: 0.56243in;" /></a></p>
<p>Figure : Talaria TWO SPI Flash Memory Layout Default Configuration</p>
<p>Figure 2 shows the SPI Flash memory layout for sample application 2
which uses the partition table spiflash_part_table.json.</p>
<p><a class="reference internal" href="../_images/image21.png"><img alt="image2" src="../_images/image21.png" style="width: 6.69291in; height: 0.56243in;" /></a></p>
<p>Figure : SPI Flash Memory Layout for SPI Flash Example Applications</p>
<p><strong>Note</strong>: The block marked as Available in Figure 2 is not assigned as a
partition in the spiflash_part_table.json since raw spi_flash operations
are used for the example applications.</p>
<p>To replace the default partition table, execute the following steps:</p>
<ol class="arabic simple">
<li><p>Load Gordon</p></li>
</ol>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>./script/boot.py –device /dev/ttyUSB2 –reset=evk42
./apps/gordon/bin/gordon.elf</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><a class="reference internal" href="../_images/image31.png"><img alt="image3" src="../_images/image31.png" style="width: 6.29921in; height: 0.85122in;" /></a></p>
</div></blockquote>
<p>Figure : Writing gordon.elf – output</p>
<ol class="arabic simple" start="2">
<li><p>Write spiflash_part_table.json in Talaria TWO module.</p></li>
</ol>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>./script/flash.py –device /dev/ttyUSB2 from_json
./examples/using_filesystem/spiflash_part_table.json</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><a class="reference internal" href="../_images/image41.png"><img alt="image4" src="../_images/image41.png" style="width: 6.29921in; height: 0.37661in;" /></a></p>
</div></blockquote>
<p>Figure : Writing spiflash_part_table.json – output</p>
</section>
<section id="sample-application-1-spiflash-sample1">
<h2>Sample application 1: spiflash_sample1<a class="headerlink" href="#sample-application-1-spiflash-sample1" title="Permalink to this heading"></a></h2>
<p>This sample application erases a sector, writes data, and then reads it
back. In the macro, we define 0x100000 as the SPI flash address for this
example.</p>
<p>In this application, the whole sector is erased before performing a
write operation.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#define SPI_FLASH_LOC 0x1c0000</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>The struct spi_mem_device is a type of object representing a SPI bus and
the SPI (Flash) memory device.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>static struct spi_mem_device flash;</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>print_spi_params() prints the SPI flash parameters.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>os_printf(”\n***SPI Flash Parameters***\n”);</p>
<p>os_printf(“id_code: 0x%X\n”, flash.sm_params.mp_idcode);</p>
<p>os_printf(“page size: %d\n”, flash.sm_params.mp_page_size);</p>
<p>os_printf(“page count: %d\n”, flash.sm_params.mp_page_count);</p>
<p>os_printf(“sector size: %d\n”, flash.sm_params.mp_sector_size);</p>
<p>os_printf(“sector erase time: %d\n”,
flash.sm_params.mp_sector_erase_time);</p>
<p>os_printf(“bulk erase time: %d\n\n”,
flash.sm_params.mp_bulk_erase_time);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p><strong>Initiate communication between SPI flash and CPU</strong>:</p>
<p>The os_flash_get_spi_dev() is used for fetching a pointer to SPI Flash
device. This pointer to spi_mem_device is used for further operations on
the SPI Flash as explained further.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>spi_mem = os_flash_get_spi_dev();</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p><strong>Erase a sector</strong>:</p>
<p>Erase a sector of the SPI Flash using spi_sector_erase() to ensure there
is no previous data and prepare it for writing. It erases the target
location first.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>os_printf(“Erasing sector at 0x%02X\n\n”, SPI_FLASH_LOC);</p>
<p>spi_sector_erase(spi_mem, SPI_FLASH_LOC);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p><strong>Write data</strong>:</p>
<p>Use spi_mem_write()to write the data to SPI flash.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>os_printf(“Writing: 0x”);</p>
<p>for(int i = 0; i &lt; sizeof data; i++)</p>
<p>{</p>
<p>os_printf(“%02X”, data[i]);</p>
<p>}</p>
<p>os_printf(”\tat 0x%02X\n\n”, SPI_FLASH_LOC);</p>
<p>spi_mem_write(spi_mem, SPI_FLASH_LOC, data, sizeof data);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p><strong>Read data</strong>:</p>
<p>Use spi_mem_read()to read the data back from SPI flash.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>uint8_t buf[sizeof data];</p>
<p>spi_mem_read(&amp;flash, SPI_FLASH_LOC, buf, sizeof data);</p>
<p>os_printf(“Read: 0x”);</p>
<p>for(int i = 0; i &lt; sizeof buf; i++)</p>
<p>{</p>
<p>os_printf(“%02X”, buf[i]);</p>
<p>}</p>
<p>os_printf(”\tat 0x%02X\n\n”, SPI_FLASH_LOC);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<section id="running-the-application">
<h3>Running the Application<a class="headerlink" href="#running-the-application" title="Permalink to this heading"></a></h3>
<p>Program spiflash_sample1.elf using the Download tool:</p>
<ol class="arabic simple">
<li><p>Launch the Download tool provided with InnoPhase Talaria TWO SDK.</p></li>
<li><p>In the GUI window:</p>
<ol class="loweralpha simple">
<li><p>Boot Target: Select the appropriate EVK from the drop-down.</p></li>
<li><p>ELF Input: Load the spiflash_sample1.elf by clicking on Select ELF
File.</p></li>
<li><p>Programming: Prog RAM or Prog Flash as per requirement.</p></li>
</ol>
</li>
</ol>
<p>For more details on using the Download tool, refer to the document:
UG_Download_Tool.pdf (path: <em>sdk_x.y\pc_tools\Download_Tool\doc</em>).</p>
</section>
<section id="expected-output">
<h3>Expected Output<a class="headerlink" href="#expected-output" title="Permalink to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>UART:NWWWWAEBuild $Id: git-f92bee540 $</p>
<p>$App:git-7bdfd62</p>
<p>SDK Ver: sdk_2.4</p>
<p>Spi Flash Demo App 1</p>
<p>***SPI Flash Parameters***</p>
<p>id_code: 0xC86515</p>
<p>page size: 256</p>
<p>page count: 8192</p>
<p>sector size: 4096</p>
<p>sectore erase time: 128000</p>
<p>bulk erase time: 768000</p>
<p>Erasing sector at 0x1C0000</p>
<p>Writing: 0xDEADBEEF at 0x1C0000</p>
<p>Read: 0xDEADBEEF at 0x1C0000</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="sample-application-2-spiflash-sample2">
<h2>Sample application 2: spiflash_sample2<a class="headerlink" href="#sample-application-2-spiflash-sample2" title="Permalink to this heading"></a></h2>
<p>One property of SPI Flash is that, when a bit is set to 0, it cannot be
set to 1 without an erase operation. Also, another property of most SPI
Flash controllers is where an erase operation is done in sectors.</p>
<p>In the Sample Application 1, we avoid this by simply erasing whole
sector before performing a write. In many cases however, we can only
erase the sector without losing data. In the sample application, we make
sure that we preserve the data in the addresses where we did not write.</p>
<p>The sample application below runs three tests:</p>
<ol class="arabic simple">
<li><p>Write data and Read at the same location. Data read will be the same
as written</p></li>
<li><p>Write different data2 at the same location without erasing. Data read
will not match because the location already had existing data</p></li>
<li><p>Write data3 at a second location. Write data at the original
location, while verifying contents first. Read data from both
locations. Data read from both locations should match what was
written</p></li>
</ol>
<p>For this application in the macro, we define 0x100000 as the SPI flash
address.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#define SPI_FLASH_LOC 0x1c0000</p>
<p>#define DATA_OFFSET 0x80</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>struct spi_mem_device is a type of object representing SPI (Flash)
memory device.</p>
<p>os_flash_get_spi_dev() is the get SPI device pointer for flash
(spi-mem).</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>spi_mem = os_flash_get_spi_dev();</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>print_spi_params() prints the SPI flash parameters.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>print_spi_params();</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>spi_sector_erase() erases a sector of the SPI flash to ensure there is
no previous data and prepare it for writing. It erases the target
location first.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>spi_sector_erase(&amp;flash, SPI_FLASH_LOC);</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>print_array_hex() prints the array as a hex decimal values.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>print_array_hex(data, sizeof data);</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p><strong>Case 1</strong>:</p>
<p>spi_mem_write() writes in a specific position in flash. The function
returns M2M_SUCCESS for successful operations and a negative value
otherwise.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>spi_mem_write(&amp;flash, SPI_FLASH_LOC, data, sizeof data);</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>spi_mem_read()function reads the data from the mentioned location in
flash memory through serial peripheral interface and print_array_hex()
prints the array as a hex decimal value.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>uint8_t buf[sizeof data];</p>
<p>spi_mem_read(&amp;flash, SPI_FLASH_LOC, buf, sizeof data);</p>
<p>os_printf(“Read: 0x”);</p>
<p>print_array_hex(buf, sizeof buf);</p>
<p>os_printf(”\tat 0x%02X\n\n”, SPI_FLASH_LOC);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p><strong>Case 2</strong>:</p>
<p>In test case 2, spi_mem_write() function writes the data in a specific
position in the same location in flash, but with different content.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>spi_mem_write(&amp;flash, SPI_FLASH_LOC, data2, sizeof data2);</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>spi_mem_read()function reads the data from mentioned location in flash
memory through serial peripheral interface. The value read will be
different from expected.</p>
<p>print_array_hex() prints the array as hex decimal values.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>spi_mem_read(&amp;flash, SPI_FLASH_LOC, buf, sizeof data2);</p>
<p>os_printf(“Read: 0x”);</p>
<p>print_array_hex(buf, sizeof buf);</p>
<p>os_printf(”\tat 0x%02X\n\n”, SPI_FLASH_LOC);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p><strong>Case 3</strong>:</p>
<p>In test case 3, spi_mem_safe_write() function writes data at a different
location in flash.</p>
<p>Post which, it writes at the same location as case 1 and 2 again.
spi_mem_read() reads the flash memory and prints it in the console.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>os_printf(“Writing: 0x”);</p>
<p>print_array_hex(data3, sizeof data3);</p>
<p>os_printf(”\tat 0x%02X\n”, SPI_FLASH_LOC+DATA_OFFSET);</p>
<p>spi_flash_safe_write(spi_mem, SPI_FLASH_LOC+DATA_OFFSET, data3,
sizeof data3);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>spi_mem_read()reads data from the location which is
SPI_FLASH_LOC+DATA_OFFSET and prints it in console.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>spi_mem_read(spi_mem, SPI_FLASH_LOC+DATA_OFFSET, buf, sizeof buf);</p>
<p>os_printf(“Read: 0x”);</p>
<p>print_array_hex(buf, sizeof buf);</p>
<p>os_printf(”\tat 0x%02X\n\n”, SPI_FLASH_LOC+DATA_OFFSET);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>print_spi_params() function prints all the parameters of the flash onto
the console.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>os_printf(”\n***SPI Flash Parameters***\n”);</p>
<p>os_printf(“id_code: 0x%X\n”, flash.sm_params.mp_idcode);</p>
<p>os_printf(“page size: %d\n”, flash.sm_params.mp_page_size);</p>
<p>os_printf(“page count: %d\n”, flash.sm_params.mp_page_count);</p>
<p>os_printf(“sector size: %d\n”, flash.sm_params.mp_sector_size);</p>
<p>os_printf(“sectore erase time: %d\n”,
flash.sm_params.mp_sector_erase_time);</p>
<p>os_printf(“bulk erase time: %d\n\n”,
flash.sm_params.mp_bulk_erase_time);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Here, we implement a function called spi_flash_safe_write(). To ensure
we can write in SPI Flash properly, we execute the following steps:</p>
<ol class="arabic simple">
<li><p>Read the contents of target address and make sure all bits are still
set to 1</p></li>
<li><p>If all contents are still 1, do a normal write operation. Write
operation is complete at this point</p></li>
<li><p>If not, read the entire contents of the sector where target address
belongs to a buffer</p></li>
<li><p>Insert the contents of the data to be written into the buffer</p></li>
<li><p>Erase the sector where the address belongs to</p></li>
<li><p>Write the buffer into the sector where the address belongs to.</p></li>
</ol>
<p>spi_flash_safe_write() reads data at target location and verifies the
data it is all Fs. big_buff is a memory buffer which has memory
allocated to it by the os_alloc() function. This function allocates a
block of memory at least size bytes in length. The largest possible
allocated memory block is 57336 bytes, but this depends on the
availability of free blocks. Memory is freed by calling os_free()
previously. This reads the sector and modifies the data.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>uint8_t *big_buff;</p>
<p>big_buff = os_alloc(dev-&gt;sm_params.mp_sector_size);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>This allocates enough data to read a whole sector.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>memset(big_buff, 0xFF, dev-&gt;sm_params.mp_sector_size);</p>
<p>uint8_t sector_num = address/dev-&gt;sm_params.mp_sector_size;</p>
<p>uint16_t offset = address%dev-&gt;sm_params.mp_sector_size;</p>
<p>uint32_t sector_start = sector_num * dev-&gt;sm_params.mp_sector_size;</p>
<p>spi_mem_read(dev, sector_start, big_buff,
dev-&gt;sm_params.mp_sector_size);</p>
<p>memcpy(big_buff+offset, data, len);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>spi_sector_erase() function erases the memory sector.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>spi_sector_erase(dev, sector_start);</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>spi_mem_write() function writes on a specific position in flash and
frees the memory by calling os_free().</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>spi_mem_write(dev, sector_start, big_buff,
dev-&gt;sm_params.mp_sector_size);</p>
<p>os_free(big_buff);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<section id="running-the-application-1">
<span id="id1"></span><h3>Running the Application<a class="headerlink" href="#running-the-application-1" title="Permalink to this heading"></a></h3>
<p>Program spiflash_sample2.elf using the Download tool:</p>
<ol class="arabic simple">
<li><p>Launch the Download tool provided with InnoPhase Talaria TWO SDK.</p></li>
<li><p>In the GUI window:</p>
<ol class="loweralpha simple">
<li><p>Boot Target: Select the appropriate EVK from the drop-down.</p></li>
<li><p>ELF Input: Load the spiflash_sample2.elf by clicking on Select ELF
File.</p></li>
<li><p>Programming: Prog RAM or Prog Flash as per requirement.</p></li>
</ol>
</li>
</ol>
<p>For more details on using the Download tool, refer to the document:
UG_Download_Tool.pdf (path: <em>sdk_x.y\pc_tools\Download_Tool\doc</em>).</p>
</section>
<section id="expected-output-1">
<span id="id2"></span><h3>Expected Output<a class="headerlink" href="#expected-output-1" title="Permalink to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>UART:NWWWWAEBuild $Id: git-f92bee540 $</p>
<p>$App:git-7bdfd62</p>
<p>SDK Ver: sdk_2.4</p>
<p>Spi Flash Demo App 2</p>
<p>***SPI Flash Parameters***</p>
<p>id_code: 0xC86515</p>
<p>page size: 256</p>
<p>page count: 8192</p>
<p>sector size: 4096</p>
<p>sectore erase time: 128000</p>
<p>bulk erase time: 768000</p>
<p>Erasing sector at 0x1C0000</p>
<p>Test 1:</p>
<p>Writing: 0xDEADBEEF at 0x1C0000</p>
<p>Read: 0xDEADBEEF at 0x1C0000</p>
<p>Test 2:</p>
<p>Writing: 0xAAAAAAAA at 0x1C0000</p>
<p>Read: 0x8AA8AAAA at 0x1C0000</p>
<p>Test 3:</p>
<p>Writing: 0xC0DEC0DE at 0x1C0080</p>
<p>Writing: 0xDEADBEEF at 0x1C0000</p>
<p>Read: 0x8AA8AAAA at 0x1C0000</p>
<p>Read: 0xC0DEC0DE at 0x1C0080</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Socket%20Wakeup.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="SSBL.html" class="btn btn-neutral float-right" title="Introduction" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023 InnoPhase IoT, Inc. | All Rights Reserved | Proprietary &amp; Confidential.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>