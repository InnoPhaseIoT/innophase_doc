<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction &mdash; InnoPhase 1.0.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js "></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="../_static/js/custom.js" defer></script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            InnoPhase
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Getting_Started_Landing_page.html">Getting Started</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Hardware-Reference.html">Hardware-Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Porting-Guide.html">Porting-Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Software_Reference/Prerequisites/libusbK_driver-Zadig.html">Software Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Development_Environments/Development_Environments.html">Development Environments</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Tools/Tools_Landing.html">Tools</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Applications-Landing_Page.html">Applications</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Regulatory%20Notices/Regulatory%20Notices.html">Regulatory Notice</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Security/Security%20-%20Landing%20Page.html">Security</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Backend%20Files%20-%20for%20cross%20referencing/Backend%20File%20Landing.html">Backend Files - for cross referencing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../about.html">About</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">InnoPhase</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Applications/Threads and Semaphores.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h1>
<p>This application note provides a brief about Threads and Semaphore APIs
available in the SDK. Accompanying sample application describes the use
of these APIs.</p>
</section>
<section id="threads-and-semaphores">
<h1>Threads and Semaphores<a class="headerlink" href="#threads-and-semaphores" title="Permalink to this heading"></a></h1>
<section id="threads">
<h2>Threads<a class="headerlink" href="#threads" title="Permalink to this heading"></a></h2>
<p>A thread is represented by the struct os_thread. This object contains
all information needed by the kernel to manage the execution of the
thread.</p>
<p>Each thread is created with a stack and an entry point. The entry point
is a function that the threads begin to execute when started by the
kernel. The thread will continue to run until it returns from this
function.</p>
<p>The threads are scheduled on a strict priority-based scheme, with eight
different priority levels 0-7, 7 having the highest priority. The
scheduler will preempt the currently running thread at any point if a
thread with a higher priority becomes ready to execute.</p>
</section>
<section id="semaphores">
<h2>Semaphores<a class="headerlink" href="#semaphores" title="Permalink to this heading"></a></h2>
<p>A semaphore provides a synchronized counter for a shared resource for
use in a thread context. Each semaphore has a value (a non-negative
number) representing <em>how much</em> of the resource is available. If the
value is only ever zero or one, it can be used as a sleeping lock. Since
waiting for a semaphore depends on the ability to sleep, it must not be
done in an interrupt context.</p>
</section>
</section>
<section id="threads-and-semaphores-apis">
<h1>Threads and Semaphores APIs<a class="headerlink" href="#threads-and-semaphores-apis" title="Permalink to this heading"></a></h1>
<section id="thread-handling-apis">
<h2>Thread handling APIs<a class="headerlink" href="#thread-handling-apis" title="Permalink to this heading"></a></h2>
<section id="os-create-thread">
<h3>os_create_thread()<a class="headerlink" href="#os-create-thread" title="Permalink to this heading"></a></h3>
<p>Creates a new thread with priority specified in flags.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>struct os_thread * os_create_thread(const char *name,
os_entrypoint_t entry, os_threadarg_t arg, uint32_t flags, size_t
stacksz)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Though the thread is placed in the run queue, there is no immediate
reschedule.</p>
<p>Parameters passed to the API are:</p>
<ol class="arabic simple">
<li><p>Name of the thread</p></li>
<li><p>Entry point for the thread</p></li>
<li><p>Argument passed to entry point - specifies attributes like a priority
for the new thread</p></li>
<li><p>Requested stack size in bytes.</p></li>
</ol>
<p>The thread continues to run until the entry point returns, at which
point return value (a pointer) can be obtained with os_join_thread().</p>
<p>Returns pointer to struct os_thread if successful, NULL otherwise.</p>
</section>
<section id="os-join-thread">
<h3>os_join_thread ()<a class="headerlink" href="#os-join-thread" title="Permalink to this heading"></a></h3>
<p>Waits for a thread to terminate and destroy the thread.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>void * os_join_thread(struct os_thread *thread)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Calling this function will suspend the execution of the calling thread
until the target thread exits. The memory used to hold the threads stack
and control block is freed.</p>
<p>The function returns the value returned by the terminating thread.</p>
<p>If the return value is of no consequence, OS_CRTHREAD_DETACHED can be
passed in flags. This causes the OS to reap the thread.</p>
</section>
<section id="os-self">
<h3>os_self()<a class="headerlink" href="#os-self" title="Permalink to this heading"></a></h3>
<p>Return reference to the calling thread.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>struct os_thread * os_self(void)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>This function returns the reference to the calling thread. This is the
same value that was returned from the os_create_thread() call used to
create this thread.</p>
</section>
</section>
<section id="semaphore-handling-apis">
<h2>Semaphore handling APIs<a class="headerlink" href="#semaphore-handling-apis" title="Permalink to this heading"></a></h2>
<section id="os-sem-init">
<h3>os_sem_init()<a class="headerlink" href="#os-sem-init" title="Permalink to this heading"></a></h3>
<p>Initializes a semaphore when passed a pointer to the semaphore where the
initial value is to be assigned to the semaphore.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>void os_sem_init(struct os_semaphore *sem, int value)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="os-sem-wait">
<h3>os_sem_wait()<a class="headerlink" href="#os-sem-wait" title="Permalink to this heading"></a></h3>
<p>Locks a semaphore. If the value of the semaphore is greater than zero,
it decrements the counter. If the value is zero, it puts the current
thread to sleep until the value becomes positive.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>void os_sem_wait(struct os_semaphore *sem)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="os-sem-wait-timeout">
<h3>os_sem_wait_timeout()<a class="headerlink" href="#os-sem-wait-timeout" title="Permalink to this heading"></a></h3>
<p>Locks a semaphore with timeout passed as parameter tmo in microseconds.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>int os_sem_wait_timeout(struct os_semaphore *sem, uint32_t tmo)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>If the value is zero, it puts the current thread to sleep for at most
tmo microseconds. If the semaphore is unlocked before the timeout
expires, it locks the semaphore and returns zero. If a timeout occurs,
-1 is returned (and the semaphore is unlocked).</p>
</section>
<section id="os-sem-post">
<h3>os_sem_post()<a class="headerlink" href="#os-sem-post" title="Permalink to this heading"></a></h3>
<p>Unlocks a semaphore. Increments the value of a semaphore and wakes the
first thread waiting for this semaphore.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>void os_sem_post(struct os_semaphore *sem)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="os-sem-waiting">
<h3>os_sem_waiting()<a class="headerlink" href="#os-sem-waiting" title="Permalink to this heading"></a></h3>
<p>Return true if there are any threads waiting for this semaphore.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>bool os_sem_waiting(struct os_semaphore *sem)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="code-walkthrough">
<h1>Code Walkthrough<a class="headerlink" href="#code-walkthrough" title="Permalink to this heading"></a></h1>
<section id="sample-application-1-thread-creation">
<h2>Sample Application 1 – Thread Creation<a class="headerlink" href="#sample-application-1-thread-creation" title="Permalink to this heading"></a></h2>
<p><strong>Note</strong>: All the applicable ELFs are available in the following
location of the SDK release package:
sdk_x.y\examples\innoos_threads_semaphores\bin).</p>
<p>x and y in sdk_x.y refer to the SDK release version. For example:
<em>sdk_2.4\examples\innoos_threads_semaphores\bin</em>.</p>
<section id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h3>
<p>The sample code in the path /examples/innoos_threads_semaphores
/src/threads_sample1.c provides more details on how to create a thread
and execute it.</p>
</section>
<section id="sample-code-walkthrough">
<h3>Sample Code Walkthrough<a class="headerlink" href="#sample-code-walkthrough" title="Permalink to this heading"></a></h3>
<p>We assign the priority and stack size of the thread using the
preprocessing directives as follows:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#define MY_APP_THREAD_PRIO 1 /* thread priority*/</p>
<p>#define MY_APP_THREAD_STACK_SIZE 512 /* thread stack size*/</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>After thread creation, we check if the creation of a thread was
successful or not. If the call to os_create_thread() is successful, the
OS schedules the thread to run where the function my_app_thread_func()
will be called. It prints the string output to the console and returns.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>/* creates a thread */</p>
<p>my_app_thread = os_create_thread(“my_app_thread”,
my_app_thread_func,NULL, MY_APP_THREAD_PRIO,
MY_APP_THREAD_STACK_SIZE);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>While the thread function is still running, the API os_join_thread()will
suspend the main thread (calling thread) until the thread to be joined
(i.e.. the ‘my_app_thread’ in this example) terminates.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>if( my_app_thread ==NULL)</p>
<p>{</p>
<p>os_printf(” thread creation failed\n”);</p>
<p>return-1;</p>
<p>}</p>
<p>/* waits for thread function to finish */</p>
<p>os_join_thread(my_app_thread);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="using-of-delays-in-threads">
<h3>Using of Delays in Threads<a class="headerlink" href="#using-of-delays-in-threads" title="Permalink to this heading"></a></h3>
<p>Delays are mainly used when we want to stop the execution flow of a
program for t units of time. The libkernel.a library provides many
function calls with different delay precision.</p>
<p>We can use the functions such as os_msleep() for milliseconds, and
os_usleep() for microseconds.</p>
<p>i.e., os_msleep(1000) will provide a 1000 millisecond delay. Consider
the example where a delay function is used:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>static void* my_app_thread_func(void* arg)</p>
<p>{</p>
<p>os_printf(“1. hello world from a thread function\n”);</p>
<p>os_msleep(1000);</p>
<p>os_printf(“2. hello world after 1000ms\n”);</p>
<p>returnNULL;</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>When the thread function is called, it outputs the first string. Then
the thread suspends for 1000 milliseconds and when it resumes execution
and then prints the second string.</p>
</section>
<section id="running-the-application">
<h3>Running the Application<a class="headerlink" href="#running-the-application" title="Permalink to this heading"></a></h3>
<p>Program threads_sample1.elf using the Download tool:</p>
<ol class="arabic simple">
<li><p>Launch the Download tool provided with InnoPhase Talaria TWO SDK.</p></li>
<li><p>In the GUI window:</p>
<ol class="loweralpha simple">
<li><p>Boot Target: Select the appropriate EVK from the drop-down.</p></li>
<li><p>ELF Input: Load the threads_sample1.elf by clicking on Select ELF
File.</p></li>
<li><p>Programming: Prog RAM or Prog Flash as per requirement.</p></li>
</ol>
</li>
</ol>
<p>For more details on using the Download tool, refer to the document:
UG_Download_Tool.pdf (path: <em>sdk_x.y/pc_tools/Download_Tool/doc</em>).</p>
<p><strong>Note</strong>: x and y refer to the SDK release version. For example:
sdk_2.4/doc.</p>
</section>
<section id="expected-output">
<h3>Expected Output<a class="headerlink" href="#expected-output" title="Permalink to this heading"></a></h3>
<p>threads_sample1.elf is created when compiling this code which gives the
following console output when programmed to Talaria TWO.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>UART:NWWWWWAE4 DWT comparators, range 0x8000</p>
<p>Build $Id: git-7e2fd6a94 $</p>
<p>app=gordon</p>
<p>flash: Gordon ready!</p>
<p>UART:NWWWWWAE4 DWT comparators, range 0x8000</p>
<p>Build $Id: git-7e2fd6a94 $</p>
<p>app=gordon</p>
<p>flash: Gordon ready!</p>
<p>Y-BOOT 208ef13 2019-07-22 12:26:54 -0500 790da1-b-7</p>
<p>ROM yoda-h0-rom-16-0-gd5a8e586</p>
<p>FLASH:PNWWWAEBuild $Id: git-65f6c1f46 $</p>
<p>$App:git-46e2bea7</p>
<p>SDK Ver: sdk_2.4</p>
<p>Threads Demo App 1</p>
<ol class="arabic simple">
<li><p>hello world from a thread function</p></li>
<li><p>hello world after 1000ms</p></li>
</ol>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="sample-application-2-thread-priorities">
<h2>Sample Application 2 – Thread Priorities<a class="headerlink" href="#sample-application-2-thread-priorities" title="Permalink to this heading"></a></h2>
<section id="overview-1">
<span id="id1"></span><h3>Overview<a class="headerlink" href="#overview-1" title="Permalink to this heading"></a></h3>
<p>The sample code in the path:
/examples/innoos_threads_semaphores/src/threads_sample2.c describes the
creation of two threads with different priority levels.</p>
</section>
<section id="sample-code-walkthrough-1">
<span id="id2"></span><h3>Sample Code Walkthrough<a class="headerlink" href="#sample-code-walkthrough-1" title="Permalink to this heading"></a></h3>
<p>Priorities are assigned for each thread as follows:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#define MY_APP_THREAD_PRIO 2 /* thread priority ie, the first
executing thread*/</p>
<p>#define MY_APP_THREAD_STACK_SIZE 512 /* thread stack size*/</p>
<p>#define MY_APP_THREAD_2_PRIO 1 /* thread priority ie, the second
executing thread*/</p>
<p>#define MY_APP_THREAD_2_STACK_SIZE 512 /* thread stack size*/</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Here, two thread variables are declared:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>/* declare os_thread variables */</p>
<p>static struct os_thread *my_app_thread;</p>
<p>static struct os_thread *my_app_thread_2;</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Post which, os_create_thread() API is called with the following boot
arguments: name of the thread, entry point for the thread, argument for
the entry point, thread priority flag and the stack size in bytes.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>/* create threads */</p>
<p>my_app_thread =os_create_thread(“my_app_thread”,
my_app_thread_func,NULL, MY_APP_THREAD_PRIO,
MY_APP_THREAD_STACK_SIZE);</p>
<p>if(NULL== my_app_thread)</p>
<p>{</p>
<p>os_printf(” thread creation failed\n”);</p>
<p>return-1;</p>
<p>}</p>
<p>my_app_thread_2 =os_create_thread(“my_app_thread_2”,
my_app_thread_func_2,NULL, MY_APP_THREAD_2_PRIO,
MY_APP_THREAD_2_STACK_SIZE);</p>
<p>if(NULL== my_app_thread_2 )</p>
<p>{</p>
<p>os_printf(” thread creation failed\n”);</p>
<p>return-1;</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Any type of variable can be passed as an argument to the threads. Here,
the thread takes a string argument which is received as an output inside
the thread function itself.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>static void* my_app_thread_func_2(void* arg)</p>
<p>{</p>
<p>do</p>
<p>{</p>
<p>flag++;</p>
<p>os_printf(“Message from Second Thread. Thread
id[%x]\n”,(unsignedint)os_self());</p>
<p>}while(flag&lt;3);</p>
<p>returnNULL;</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>To join threads, os_join_thread()API is used as shown in the following
code block:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>/* waits for thread function to finish */</p>
<p>os_join_thread(my_app_thread);</p>
<p>os_join_thread(my_app_thread_2);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="running-the-application-1">
<span id="id3"></span><h3>Running the Application<a class="headerlink" href="#running-the-application-1" title="Permalink to this heading"></a></h3>
<p>Program threads_sample2.elf using the Download tool:</p>
<ol class="arabic simple">
<li><p>Launch the Download tool provided with InnoPhase Talaria TWO SDK.</p></li>
<li><p>In the GUI window:</p>
<ol class="loweralpha simple">
<li><p>Boot Target: Select the appropriate EVK from the drop-down.</p></li>
<li><p>ELF Input: Load the threads_sample2.elf by clicking on Select ELF
File.</p></li>
<li><p>Programming: Prog RAM or Prog Flash as per requirement.</p></li>
</ol>
</li>
</ol>
<p>For more details on using the Download tool, refer to the document:
UG_Download_Tool.pdf (path: <em>sdk_x.y/pc_tools/Download_Tool/doc</em>).</p>
<p><strong>Note</strong>: x and y refer to the SDK release version. For example:
sdk_2.4/doc.</p>
</section>
<section id="expected-output-1">
<span id="id4"></span><h3>Expected Output<a class="headerlink" href="#expected-output-1" title="Permalink to this heading"></a></h3>
<p>threads_sample2.elf is created when compiling this code which gives the
following console output when programmed to Talaria TWO.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>UART:NWWWWWAE4 DWT comparators, range 0x8000</p>
<p>Build $Id: git-7e2fd6a94 $</p>
<p>app=gordon</p>
<p>flash: Gordon ready!</p>
<p>Y-BOOT 208ef13 2019-07-22 12:26:54 -0500 790da1-b-7</p>
<p>ROM yoda-h0-rom-16-0-gd5a8e586</p>
<p>FLASH:PNWWWAEBuild $Id: git-65f6c1f46 $</p>
<p>$App:git-46e2bea7</p>
<p>SDK Ver: sdk_2.4</p>
<p>Threads Demo App 2</p>
<p>Message from First Thread. Thread id[bf780]</p>
<p>Message from First Thread. Thread id[bf780]</p>
<p>Message from First Thread. Thread id[bf780]</p>
<p>Message from Second Thread. Thread id[bfa00]</p>
<p>Message from Second Thread. Thread id[bfa00]</p>
<p>Message from Second Thread. Thread id[bfa00]</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="sample-application-3-thread-stack-size">
<h2>Sample Application 3 – Thread &amp; Stack Size<a class="headerlink" href="#sample-application-3-thread-stack-size" title="Permalink to this heading"></a></h2>
<section id="overview-2">
<span id="id5"></span><h3>Overview<a class="headerlink" href="#overview-2" title="Permalink to this heading"></a></h3>
<p>In the sample code in the path:
/examples/innoos_threads_semaphores/src/threads_sample3.c, threads are
created with a given stack size in a loop. After creating a few threads,
further thread creation fails due to the stack size. If the stack size
for each thread is lowered, then multiple threads can co-exist.</p>
</section>
<section id="sample-code-walkthrough-2">
<span id="id6"></span><h3>Sample Code Walkthrough<a class="headerlink" href="#sample-code-walkthrough-2" title="Permalink to this heading"></a></h3>
<p>Thread stack sized defined as a macro:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#define THREAD_BASICS_STACK_SIZE 1024 /* thread stack size*/</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Here, threads are created in a loop until failure occurs. If thread
creation fails, os_create_thread() returns a NULL pointer:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>/* creates a threads, until creation of thread fails */</p>
<p>while(1)</p>
<p>{ thread_id =
os_create_thread(“THREAD_BASICS”,thread_sample_thread_func,</p>
<p>NULL, OS_CRTHREAD_DETACHED|THREAD_BASICS_PRIO,
THREAD_BASICS_STACK_SIZE);</p>
<p>if(NULL== thread_id)</p>
<p>{</p>
<p>os_printf(“resource not available. thread creation failed.\n”);</p>
<p>os_error(OS_ERR_INTERNAL_ERROR);</p>
<p>}</p>
<p>os_sleep_us(10*1000, OS_TIMEOUT_NO_WAKEUP);</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Each thread prints a text, and sleeps inside a while loop. If the thread
is not sleeping, then thread creation might not fail. This is because,
resources allocated for the earlier threads were on exit and are
available for new threads.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>/* the thread function */</p>
<p>static void* thread_sample_thread_func(void* arg)</p>
<p>{</p>
<p>os_printf(“%03d:thread created\n”,++thread_count);</p>
<p>while(1)</p>
<p>{</p>
<p>os_sleep_us(1000*1000, OS_TIMEOUT_NO_WAKEUP);</p>
<p>}</p>
<p>return NULL;</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Changing the stack size and the number of threads created before failure
increases is as defined in the following code:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#define THREAD_BASICS_STACK_SIZE 512 /* thread stack size*/</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="running-the-application-2">
<span id="id7"></span><h3>Running the Application<a class="headerlink" href="#running-the-application-2" title="Permalink to this heading"></a></h3>
<p>Program threads_sample3.elf using the Download tool:</p>
<ol class="arabic simple">
<li><p>Launch the Download tool provided with InnoPhase Talaria TWO SDK.</p></li>
<li><p>In the GUI window:</p>
<ol class="loweralpha simple">
<li><p>Boot Target: Select the appropriate EVK from the drop-down.</p></li>
<li><p>ELF Input: Load the threads_sample3.elf by clicking on Select ELF
File.</p></li>
<li><p>Programming: Prog RAM or Prog Flash as per requirement.</p></li>
</ol>
</li>
</ol>
<p>For more details on using the Download tool, refer to the document:
UG_Download_Tool.pdf (path: <em>sdk_x.y/pc_tools/Download_Tool/doc</em>).</p>
<p><strong>Note</strong>: x and y refer to the SDK release version. For example:
sdk_2.4/doc.</p>
</section>
<section id="expected-output-2">
<span id="id8"></span><h3>Expected Output<a class="headerlink" href="#expected-output-2" title="Permalink to this heading"></a></h3>
<p>threads_sample3.elf is created when compiling this code which gives the
following console output when programmed to Talaria TWO.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>UART:NWWWWWAE4 DWT comparators, range 0x8000</p>
<p>Build $Id: git-7e2fd6a94 $</p>
<p>app=gordon</p>
<p>flash: Gordon ready!</p>
<p>Y-BOOT 208ef13 2019-07-22 12:26:54 -0500 790da1-b-7</p>
<p>ROM yoda-h0-rom-16-0-gd5a8e586</p>
<p>FLASH:PNWWWAEBuild $Id: git-65f6c1f46 $</p>
<p>$App:git-46e2bea7</p>
<p>SDK Ver: sdk_2.4</p>
<p>Threads Demo App 3</p>
<p>001:thread created</p>
<p>002:thread created</p>
<p>003:thread created</p>
<p>004:thread created</p>
<p>005:thread created</p>
<p>006:thread created</p>
<p>007:thread created</p>
<p>008:thread created</p>
<p>009:thread created</p>
<p>010:thread created</p>
<p>011:thread created</p>
<p>012:thread created</p>
<p>013:thread created</p>
<p>014:thread created</p>
<p>015:thread created</p>
<p>016:thread created</p>
<p>017:thread created</p>
<p>018:thread created</p>
<p>019:thread created</p>
<p>020:thread created</p>
<p>021:thread created</p>
<p>022:thread created</p>
<p>023:thread created</p>
<p>024:thread created</p>
<p>025:thread created</p>
<p>026:thread created</p>
<p>027:thread created.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>697:thread created</p>
<p>698:thread created</p>
<p>resource not available. thread creation failed.</p>
<p>OS_ERROR 0xfc</p>
<p>OS_UNEXPECTED_EXCEPTION 0x6</p>
<p>R0=00000030 R1=0004b6d4 R2=00fc0d00 R3=00000000</p>
<p>R4=00000200 R5=001049cd R6=00104a47 R7=07777777</p>
<p>R8=08888888 R9=09999999 R10=0aaaaaaa R11=0bbbbbbb</p>
<p>R12=000b2be3 SP=000b2c84 LR=00104a1b PC=00104a1a</p>
<p>xPSR=21000000 CONTROL=00000000 CFSR=00010000 BFAR=e000ed38</p>
<p>STACK:</p>
<p>0x000b2cc8: 00000200 01111111 04444444 05555555</p>
<p>0x000b2cd8: 06666666 00044e81 6e69616d 2988fa00</p>
<p>0x000b2ce8: 001049f1 07f83201 00000002 000b2c84</p>
<p>0x000b2cf8: 000b24e8 a5631209 000b2d00 000b2d00</p>
<p>0x000b2d08: 000b2d08 000b2d08 0004000c 0004000c</p>
<p>0x000b2d18: 000bf5e0 000bed20 000b2d20 000b2d20</p>
<p>0x000b2d28: 00000000 00000000 2df339e6 7349fc7f</p>
<p>0x000b2d38: 9ae964cd 00b1164b 345d406c 39c04a4e</p>
<p>0x000b2d48: ffc8daa2 abfbaff5 8fb90474 1b15e267</p>
<p>0x000b2d58: 7e319424 5ba8eb37 77759125 fdb7ba53</p>
<p>0x000b2d68: ebadcc99 201b8df4 0b444886 67873273</p>
<p>0x000b2d78: 297324ac 11501758 e51c63cf 036a56b6</p>
<p>0x000b2d88: 70db1ab6 040913ed aa791662 5dd9b7f3</p>
<p>0x000b2d98: e309dfe6 83476ca2 cd864e0a 33f21c84</p>
<p>0x000b2da8: 6c98c51e dcf15390 84ece867 1518ef2a</p>
<p>0x000b2db8: e50d55a8 b8202166 b3b87b4e 9974b048</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="sample-application-4-thread-semaphores">
<h2>Sample Application 4 – Thread &amp; Semaphores<a class="headerlink" href="#sample-application-4-thread-semaphores" title="Permalink to this heading"></a></h2>
<section id="overview-3">
<span id="id9"></span><h3>Overview<a class="headerlink" href="#overview-3" title="Permalink to this heading"></a></h3>
<p>In the sample code in the path:
/examples/innoos_threads_semaphores/src/threads_semaphores.c, three
threads are created, each with separate thread functions. By using a
semaphore, the threads will execute according to the value used for the
initialization of the semaphore variable.</p>
<p>In this application, Thread1 initially takes the semaphore while Thread2
and Thread3 wait until Thread1 completes its task and releases the
semaphore. Thread2 and Thread3 are both waiting for the semaphore but in
two different ways.</p>
</section>
<section id="sample-code-walkthrough-3">
<span id="id10"></span><h3>Sample Code Walkthrough<a class="headerlink" href="#sample-code-walkthrough-3" title="Permalink to this heading"></a></h3>
<p>Here we are using three threads as shown below:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>my_app_thread_1 =os_create_thread(“my_app_thread_1”,
my_app_thread_func_1, NULL, SEMAPHORE_SAMPLE_THREAD_PRIORITY,
SEMAPHORE_SAMPLE_THREAD_STACK_SIZE);</p>
<p>/* creating thread 1 */</p>
<p>my_app_thread_2
=os_create_thread(“my_app_thread_2”,my_app_thread_func_2, NULL,
SEMAPHORE_SAMPLE_THREAD_PRIORITY,
SEMAPHORE_SAMPLE_THREAD_STACK_SIZE);</p>
<p>/* creating thread 2 */</p>
<p>my_app_thread_3 =os_create_thread(“my_app_thread_3”,
my_app_thread_func_3,NULL, SEMAPHORE_SAMPLE_THREAD_PRIORITY,
SEMAPHORE_SAMPLE_THREAD_STACK_SIZE);</p>
<p>/* creating thread 2 */</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Before thread creation, there is a need to declare and initialize the
semaphore variable by using the following statements:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>static struct os_semaphore my_sem;</p>
<p>…</p>
<p>…</p>
<p>…</p>
<p>/* initializes a semaphore. this has to be called before using
my_sem.</p>
<p>init with 0</p>
<p>*/</p>
<p>os_sem_init(&amp;my_sem,0);</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>It is required to initialize the semaphore variable using
os_sem_init()before using the semaphore variable. In the code, the
semaphore is initialized to 0.</p>
<p>Consider the thread functions defined for our created threads:</p>
<p>my_app_thread_func_1() for Thread1:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>static void* my_app_thread_func_1(void* arg)</p>
<p>{</p>
<p>os_printf(”\n%x:%u:from thread 1. doing initial tasks”,</p>
<p>SEMAPHORE_SAMPLE_CURRENT_THREAD_ID,os_systime());</p>
<p>/*sleeping for some time, still other threads waiting*/</p>
<p>os_msleep(1000);</p>
<p>/*checking is there any one waiting on the thread*/</p>
<p>os_printf(”\n%x:%u:from thread 1. Is any one waiting for sem:%s”,</p>
<p>SEMAPHORE_SAMPLE_CURRENT_THREAD_ID,os_systime(),</p>
<p>os_sem_waiting(&amp;my_sem)==1?”Yes”:”No”);</p>
<p>os_printf(”\n%x:%u:from thread 1. initial jobs done. now thread 2/3
can start.”</p>
<p>” going to release the semaphore”,</p>
<p>SEMAPHORE_SAMPLE_CURRENT_THREAD_ID,os_systime());</p>
<p>/*releasing the semaphore*/</p>
<p>os_sem_post(&amp;my_sem );</p>
<p>/*checking is there any one waiting on the thread*/</p>
<p>return NULL;</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>my_app_thread_func_2() for Thread2.</p>
<p>Thread 2 is waiting to acquire the semaphore. Once it does, it waits for
3000 milliseconds post which it releases the semaphore.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>static void* my_app_thread_func_2(void* arg)</p>
<p>{</p>
<p>os_printf(”\n%x:%u:from thread 2. waiting for semaphore”,</p>
<p>SEMAPHORE_SAMPLE_CURRENT_THREAD_ID,os_systime());</p>
<p>/*waiting on the semaphore*/</p>
<p>os_sem_wait(&amp;my_sem );</p>
<p>os_printf(”\n%x:%u:from thread 2. got semaphore”,</p>
<p>SEMAPHORE_SAMPLE_CURRENT_THREAD_ID,os_systime());</p>
<p>/*thread 2 business logic here*/</p>
<p>os_printf(”\n%x:%u:from thread 2. releasing semaphore\n”,</p>
<p>SEMAPHORE_SAMPLE_CURRENT_THREAD_ID,os_systime());</p>
<p>/*releasing the semaphore*/</p>
<p>os_sem_post(&amp;my_sem );</p>
<p>return NULL;</p>
<p>}</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>my_app_thread_func_3() for Thread3.</p>
<p>Thread 3 is waiting to acquire the semaphore until it times out. If it
times out, it will loop back and once again try to acquire the
semaphore.</p>
<p>Once it does, it will complete its task and releases the semaphore:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>static void* my_app_thread_func_3(void* arg)</p>
<p>{</p>
<p>int ret;</p>
<p>os_printf(”\n%x:%u:from thread 3. waiting for semaphore”,</p>
<p>SEMAPHORE_SAMPLE_CURRENT_THREAD_ID,os_systime());</p>
<p>while(1)</p>
<p>{</p>
<p>/*If the value of the semaphore is greater than zero,</p>
<p>decrement the counter and return zero; here the value of the
semaphore is 1*/</p>
<p>ret = os_sem_wait_timeout(&amp;my_sem,1000000);</p>
<p>if(ret)</p>
<p>{</p>
<p>os_printf(”\n%x:%u:from thread 3. timedout. still waiting for
semaphore. ret:%d”,</p>
<p>SEMAPHORE_SAMPLE_CURRENT_THREAD_ID,os_systime(), ret);</p>
<p>/*based on the application requirement, application can decide</p>
<p>whether to wait more or continue with ‘could not lock’ logic*/</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>os_printf(”\n%x:%u:from thread 3. got semaphore. ret:%d”,</p>
<p>SEMAPHORE_SAMPLE_CURRENT_THREAD_ID,os_systime(), ret);</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>os_printf(”\n%x:%u:from thread 3. releasing semaphore\n”,</p>
<p>SEMAPHORE_SAMPLE_CURRENT_THREAD_ID,os_systime());</p>
<p>/*releasing the semaphore*/</p>
<p>os_sem_post(&amp;my_sem );</p>
<p>returnNULL; }</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
<section id="running-the-application-3">
<span id="id11"></span><h3>Running the Application<a class="headerlink" href="#running-the-application-3" title="Permalink to this heading"></a></h3>
<p>Program threads_semaphores.elf using the Download tool:</p>
<ol class="arabic simple">
<li><p>Launch the Download tool provided with InnoPhase Talaria TWO SDK.</p></li>
<li><p>In the GUI window:</p>
<ol class="loweralpha simple">
<li><p>Boot Target: Select the appropriate EVK from the drop-down.</p></li>
<li><p>ELF Input: Load the threads_semaphores.elf by clicking on Select
ELF File.</p></li>
<li><p>Programming: Prog RAM or Prog Flash as per requirement.</p></li>
</ol>
</li>
</ol>
<p>For more details on using the Download tool, refer to the document:
UG_Download_Tool.pdf (path: <em>sdk_x.y/pc_tools/Download_Tool/doc</em>).</p>
<p><strong>Note</strong>: x and y refer to the SDK release version. For example:
sdk_2.4/doc.</p>
</section>
<section id="expected-output-3">
<span id="id12"></span><h3>Expected Output<a class="headerlink" href="#expected-output-3" title="Permalink to this heading"></a></h3>
<p>threads_semaphores.elf is created when compiling this code which gives
the following console output when programmed to Talaria TWO.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>UART:NWWWWWAE4 DWT comparators, range 0x8000</p>
<p>Build $Id: git-7e2fd6a94 $</p>
<p>app=gordon</p>
<p>flash: Gordon ready!</p>
<p>Y-BOOT 208ef13 2019-07-22 12:26:54 -0500 790da1-b-7</p>
<p>ROM yoda-h0-rom-16-0-gd5a8e586</p>
<p>FLASH:PNWWWAEBuild $Id: git-65f6c1f46 $</p>
<p>$App:git-46e2bea7</p>
<p>SDK Ver: sdk_2.4</p>
<p>Threads Semaphores Demo App</p>
<p>bfb80:95336:from thread 1. doing initial tasks</p>
<p>b35e8:95382:from thread 2. waiting for semaphore</p>
<p>b3868:95543:from thread 3. waiting for semaphore</p>
<p>bfb80:1095384:from thread 1. Is any one waiting for sem:Yes</p>
<p>bfb80:1095434:from thread 1. initial jobs done. now thread 2/3 can
start. going to release the semaphore</p>
<p>b35e8:1095504:from thread 2. got semaphore</p>
<p>b3868:1095593:from thread 3. timedout. still waiting for semaphore.
ret:-1</p>
<p>b3868:2095658:from thread 3. timedout. still waiting for semaphore.
ret:-1</p>
<p>b3868:3095723:from thread 3. timedout. still waiting for semaphore.
ret:-1</p>
<p>b35e8:4095550:from thread 2. releasing semaphore</p>
<p>b3868:4095601:from thread 3. got semaphore. ret:0</p>
<p>b3868:4095647:from thread 3. releasing semaphore</p>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023 InnoPhase IoT, Inc. | All Rights Reserved | Proprietary &amp; Confidential.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>