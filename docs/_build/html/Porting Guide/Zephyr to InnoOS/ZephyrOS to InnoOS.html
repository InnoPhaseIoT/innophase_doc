<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Create Threads &mdash; InnoPhase 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Support" href="../../Support/Support.html" />
    <link rel="prev" title="Create tasks (threads)" href="../FreeRTOS%20to%20InnoOS/FreeRTOS%20to%20InnoOS.html" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js "></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="../../_static/js/custom.js" defer></script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            InnoPhase
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Getting%20Started/Getting%20Started%20-%20Landing%20Page.html">Getting Started</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Hardware%20Reference/Hardware-Reference.html">Hardware-Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Software%20Reference/Software_Reference_Landing_Page.html">Software Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Development%20Environments/Development%20Environments%20-%20Landing%20Page.html">Development Environments</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Tools/Tools-landing%20page.html">Tools</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Applications/Applications%20-%20Landing%20Page.html">Applications</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Regulatory%20Notices/Regulatory%20Notices.html">Regulatory Notices</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Security/Security%20-%20Landing%20Page.html">Security</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../Porting-Guide.html">Porting-Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../Porting-Guide.html#free-rtos-to-innoos">Free RTOS to InnoOS</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../Porting-Guide.html#zephyros-to-innoos">ZephyrOS to innoOS</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Create Threads</a></li>
<li class="toctree-l3"><a class="reference internal" href="#message-queues">Message Queues</a></li>
<li class="toctree-l3"><a class="reference internal" href="#soft-timers">Soft Timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semaphores">Semaphores</a></li>
<li class="toctree-l3"><a class="reference internal" href="#work-queue">Work Queue</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Support/Support.html">Support</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Disclaimers/Disclaimers.html">Disclaimer</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Appendix/Appendix-Landing_Page.html">Appendix</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">InnoPhase</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../Porting-Guide.html">Porting-Guide</a></li>
      <li class="breadcrumb-item active">Create Threads</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/Porting Guide/Zephyr to InnoOS/ZephyrOS to InnoOS.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>This porting guide describes porting of the ZephyrOS code to InnoOS for
a few common scenarios.</p>
<section id="create-threads">
<h1>Create Threads<a class="headerlink" href="#create-threads" title="Permalink to this heading"></a></h1>
<p>In InnoOS, a thread is created using the function os_create_thread(..).
The function os_create_thread, takes five input parameters:</p>
<ol class="arabic simple">
<li><p>Name of the thread to create</p></li>
<li><p>Entry function of the thread task</p></li>
<li><p>Argument(s) of the entry function</p></li>
<li><p>Priority of the thread</p></li>
<li><p>Stack size of the thread</p></li>
</ol>
<p>Following is the prototype of the function os_create_thread:</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">Table 1: Create a thread</span><a class="headerlink" href="#id1" title="Permalink to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>struct os_thread *os_create_thread(const char *name,
os_entrypoint_t entry, os_threadarg_t arg, uint32_t flags, size_t
stacksz);</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td></td>
</tr>
</tbody>
</table>
<p>Contrary to ZephyrOS, in InnoOS the entry function always returns NULL.
It is not possible to pass more than one argument to the entry function.
An alternative is to use a pointer to a struct to pass more than one
argument.</p>
<p>The following example provides a comparison between Zephyr and InnoOS,
on how a thread is created:</p>
<table class="docutils align-default" id="id2">
<caption><span class="caption-text">Table 2: Message queues</span><a class="headerlink" href="#id2" title="Permalink to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p><strong>ZephyrOS</strong></p></th>
<th class="head"><p><strong>InnoOS</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>static void task(void)</p>
<p>{</p>
<p>int cnt = 0;</p>
<p>for (;;){</p>
<p>printk(“Count %d\n”,cnt++);</p>
<p>k_sleep(K_SECONDS(1));</p>
<p>}</p>
<p>}</p>
<p>int main(void)</p>
<p>{</p>
<p><a href="#id6"><span class="problematic" id="id7">K_</span></a>
THREAD_STACK_DEFINE(stack,1024);</p>
<p>static struct k_thread
my_thread;</p>
<p>k_thread_create(</p>
<p>&amp;my_thread,</p>
<p>stack,</p>
<p>K_THREAD_STACK_SIZEOF(stack),</p>
<p>(k_thread_entry_t) task,</p>
<p>NULL,</p>
<p>NULL,</p>
<p>NULL,</p>
<p>1,</p>
<p>0,</p>
<p>K_NO_WAIT) ;</p>
<p>return 0;</p>
<p>}</p>
</td>
<td><p>static void * task(void *arg)</p>
<p>{</p>
<p>int cnt = 0;</p>
<p>for (;;) {</p>
<p>os_printf(“Count %d\n”, cnt++);</p>
<p>os_sleep_us(SYSTIME_SEC(1),</p>
<p>}</p>
<p>return NULL; }</p>
<p>int main(void)</p>
<p>{</p>
<p>os_create_thread(</p>
<p>“task”,</p>
<p>task,</p>
<p>NULL,</p>
<p>1,</p>
<p>1024);</p>
<p>return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="message-queues">
<h1>Message Queues<a class="headerlink" href="#message-queues" title="Permalink to this heading"></a></h1>
<p>In ZephyrOS, the message queue must be initiated separately. To do so,
it is required to allocate a message buffer that is aligned. In addition
to this, in ZephyrOS, the receiver is required to specify the message
queue from which it wants to get the message from.</p>
<p>There is also an option to peek a message from the queue, without
removing it from the queue.</p>
<p>In InnoOS, every thread gets a message queue when a thread is created
(i.e., after calling os_create_thread()). Hence, the message queues are
not created separately.</p>
<p>In InnoOS, message queues have no maximum number of items, and each
message on the queue can be of different sizes. InnoOS uses the message
type (field) to differentiate between messages. The sender specifies to
which thread the message should be sent. The receiver does not specify
the queue, as it receives it from its own thread queue. The receiver has
no reception timeout, but there is a flag which tells if the call should
wait or return immediately if there is no message in the reception queue
for the moment.</p>
<p>Additionally, in InnoOS, it is also possible to use an os_recvmsg_type
to wait for a specific message type.</p>
<table class="docutils align-default" id="id3">
<caption><span class="caption-text">Table 3: Soft timers</span><a class="headerlink" href="#id3" title="Permalink to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p><strong>ZephyrOS</strong></p></th>
<th class="head"><p><strong>InnoOS</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>struct k_msgq msgq;</p>
<p>K_THREAD_STACK_DEFINE(stack1,
1024);</p>
<p>K_THREAD_STACK_DEFINE(stack2,
1024);</p>
<p>static void tx()</p>
<p>{</p>
<p>int item = 0xaddababe;</p>
<p>for(;;) {</p>
<p>if (k_msgq_put(&amp;msgq, &amp;item,</p>
<p>K_SECONDS(0.5))==0)</p>
<p>printk(“Send ok\n”);</p>
<p>else</p>
<p>printk(“Send failed\n”);</p>
<p>k_sleep(K_SECONDS(1));</p>
<p>}</p>
<p>}</p>
<p>static void rx()</p>
<p>{</p>
<p>int item;</p>
<p>for(;;) {</p>
<p>if (k_msgq_get(&amp;msgq, &amp;item,</p>
<p>K_SECONDS(0.5))==0)</p>
<p>printk(“Received %x\n”,item);</p>
<p>else</p>
<p>printk(“Reception failed\n”);</p>
<p>k_sleep(K_SECONDS(1));</p>
<p>}</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>char __aligned(4)
msg_buffer[5*sizeof(void*)];</p>
<p>k_msgq_init(&amp;msgq, msg_buffer,
sizeof(void*), 5);</p>
<p>static struct k_thread
thread_rx;</p>
<p>static struct k_thread
thread_tx;</p>
<p>k_thread_create(&amp;thread_tx,
stack1,</p>
<p>K_THREAD_STACK_SIZEOF(stack1),</p>
<p>(k_thread_entry_t) tx, NULL,
NULL, NULL,</p>
<p>1, 0, K_NO_WAIT) ;</p>
<p>k_thread_create(&amp;thread_rx,
stack2,</p>
<p>K_THREAD_STACK_SIZEOF(stack2),</p>
<p>(k_thread_entry_t) rx, NULL,
NULL, NULL,</p>
<p>1, 0, K_NO_WAIT) ;</p>
<p>return 0;</p>
<p>}</p>
</td>
<td><p>#define MSG_TYPE 100</p>
<p>struct os_thread *thread_rx;</p>
<p>struct os_thread *thread_tx;</p>
<p>struct my_msg {</p>
<p>struct os_msg msg;</p>
<p>int data;</p>
<p>};</p>
<p>static void * tx(void *arg)</p>
<p>{</p>
<p>for (;;) {</p>
<p>struct my_msg *msg = (struct
my_msg*)</p>
<p>os_msg_alloc(MSG_TYPE, sizeof
*msg);</p>
<p>msg-&gt;data = 0xaddababe;</p>
<p>os_sendmsg(thread_rx, &amp;msg-&gt;msg);</p>
<p>os_sleep_us(SYSTIME_SEC(1),</p>
<p>OS_TIMEOUT_WAKEUP);</p>
<p>}</p>
<p>return NULL;</p>
<p>}</p>
<p>static void * rx(void *arg)</p>
<p>{</p>
<p>for (;;) {</p>
<p>struct my_msg *rec = (struct
my_msg*)os_recvmsg(false);</p>
<p>os_printf(“Received %x from
%s\n”, rec-&gt;data,</p>
<p>os_t
hread_name(rec-&gt;msg.msg_sender));</p>
<p>os_msg_release((struct os_msg
*)rec);</p>
<p>}</p>
<p>return NULL;</p>
<p>}</p>
<p>int main(void)</p>
<p>{</p>
<p>thread_tx =
os_create_thread(“tx”, tx, NULL,
1, 1024);</p>
<p>thread_rx =
os_create_thread(“rx”, rx, NULL,
1, 1024);</p>
<p>return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="soft-timers">
<h1>Soft Timers<a class="headerlink" href="#soft-timers" title="Permalink to this heading"></a></h1>
<p>Table 3 depicts an example where the timer is run multiple times.
ZephyrOS does not have a callback which counts the number of times the
timer has elapsed in total. It only has a status function which checks
the number of times it has elapsed since the status was last read and
then resets it to zero. Because of this, there is a need to have a
global count which will keep track of the number of times the timer has
elapsed in total.</p>
<p>In InnoOS, the timers are called callouts, and the APIs are prefixed
with callout_. The preferred coding style is to use a struct including
the timer (callout) and the parameters needed.</p>
<p>For example: cnt in this example.</p>
<p>In the callback function, the pointer to the struct is returned via the
container_of macro. This will lead to a lot of different coding
opportunities with InnoOS.</p>
<p>In InnoOS, there is an additional function called
callout_scedule_at(struct callout *co, uint32_t time)which offers the
possibility to schedule the callout to start after a few microseconds.</p>
<table class="docutils align-default" id="id4">
<caption><span class="caption-text">Table 4: Semaphores</span><a class="headerlink" href="#id4" title="Permalink to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p><strong>ZephyrOS</strong></p></th>
<th class="head"><p><strong>InnoOS</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint32_t cnt=0;</p>
<p>struct k_timer timer;</p>
<p>static void</p>
<p>timer_callback()</p>
<p>{</p>
<p>cnt+=k_timer_status_get(&amp;timer);</p>
<p>printk(“cnt: %u\n”, cnt);</p>
<p>if (cnt&lt;10)</p>
<p>/* timer is auto-reloaded */</p>
<p>k_timer_start(&amp;timer,
K_SECONDS(1),</p>
<p>K_NO_WAIT);</p>
<p>else {</p>
<p>k_timer_stop(&amp;timer);</p>
<p>printk(“Ready!\n”);</p>
<p>}</p>
<p>}</p>
<p>int</p>
<p>main(void)</p>
<p>{</p>
<p>k_timer_init(&amp;timer,
timer_callback, NULL);</p>
<p>k_timer_start(&amp;timer,
K_SECONDS(1),</p>
<p>K_NO_WAIT);</p>
<p>return 0;</p>
<p>}</p>
</td>
<td><p>#include &lt;kernel/os.h&gt;</p>
<p>#include &lt;kernel/callout.h&gt;</p>
<p>struct my_state {</p>
<p>struct callout timer;</p>
<p>uint32_t cnt;</p>
<p>} state;</p>
<p>static void __irq</p>
<p>timer_callback(struct callout
*co)</p>
<p>{</p>
<p>struct my_state *state =
container_of(co, struct my_state,
timer);</p>
<p>state-&gt;cnt++;</p>
<p>os_printf(“cnt: %u\n”,
state-&gt;cnt);</p>
<p>if (state-&gt;cnt &lt; 10)</p>
<p>/* Reschedule the timer */</p>
<p>callout_schedule(&amp;state-&gt;timer,
SYSTIME_SEC(1));</p>
<p>else</p>
<p>os_printf(“Ready\n”);</p>
<p>}</p>
<p>int</p>
<p>main(void)</p>
<p>{</p>
<p>callout_init(&amp;state.timer,
timer_callback);</p>
<p>callout_schedule(&amp;state.timer,
SYSTIME_SEC(1));</p>
<p>return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="semaphores">
<h1>Semaphores<a class="headerlink" href="#semaphores" title="Permalink to this heading"></a></h1>
<p>The differences between ZephyrOS and InnoOS are minor when it comes to
semaphores. Table 4 depicts the different functions.</p>
<table class="docutils align-default" id="id5">
<caption><span class="caption-text">Table 5: Work queue</span><a class="headerlink" href="#id5" title="Permalink to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p><strong>ZephyrOS</strong></p></th>
<th class="head"><p><strong>InnoOS</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>struct k_sem semaphore;</p>
<p>k_sem_init(&amp;semaphore, 1,
MAX_VALUE);</p>
<p>k_sem_take(&amp;semaphore, timeout);</p>
<p>k_sem_give(&amp;semaphore);</p>
</td>
<td><p>struct os_semaphore semaphore;</p>
<p>os_sem_init(&amp;semaphore, 1);
os_sem_wait_timeout(&amp;semaphore,
timeout);</p>
<p>os_sem_post(&amp;semaphore);</p>
</td>
</tr>
</tbody>
</table>
<p>InnoOS has the API os_sem_wait(&amp;semaphore), which is without a timeout
and blocks until the semaphore is taken. The same behavior can be
achieved in ZephyrOS using k_sem_take, if the timeout argument is set to
K_MAX_FOREVER.</p>
</section>
<section id="work-queue">
<h1>Work Queue<a class="headerlink" href="#work-queue" title="Permalink to this heading"></a></h1>
<p>ZephyrOS and InnoOS work queues are similar. They can write to the
systems work queue and create new work queues. Following is an example
of both writing to the systems work queue:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>ZephyrOS</strong></p></th>
<th class="head"><p><strong>InnoOS</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>struct my_state{</p>
<p>struct k_work mining;</p>
<p>};</p>
<p>static void</p>
<p>working_in_a_coalmine(struct
k_work *work)</p>
<p>{</p>
<p>struct my_state *state =
CONTAINER_OF(work,</p>
<p>struct my_state, mining);</p>
<p>// do some work…</p>
<p>}</p>
<p>static void</p>
<p>interrupt_service_receive(struct
my_state *state)</p>
<p>{</p>
<p>k_work_submit(&amp;state-&gt;mining);</p>
<p>}</p>
<p>static void</p>
<p>init_mining(struct my_state
*state)</p>
<p>{</p>
<p>//Associate the work function
with the struct k_work object</p>
<p>k_work_init(&amp;state-&gt;mining,
working_in_a_coalmine);</p>
<p>}</p>
</td>
<td><p>struct my_state {</p>
<p>struct os_work mining;</p>
<p>};</p>
<p>static void</p>
<p>working_in_a_coalmine(struct
os_work *work)</p>
<p>{</p>
<p>struct my_state *state =
container_of(work, struct
my_state,</p>
<p>mining);</p>
<p>// do some work…</p>
<p>}</p>
<p>static void</p>
<p>interrupt_service_receive(struct
my_state *state)</p>
<p>{</p>
<p>os_q
ueue_system_work(&amp;state-&gt;mining);</p>
<p>}</p>
<p>static void</p>
<p>init_mining(struct my_state
*state)</p>
<p>{</p>
<p>//Associate the work function
with the struct os_work object</p>
<p>os_init_work(&amp;state-&gt;mining,
working_in_a_coalmine);</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../FreeRTOS%20to%20InnoOS/FreeRTOS%20to%20InnoOS.html" class="btn btn-neutral float-left" title="Create tasks (threads)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../Support/Support.html" class="btn btn-neutral float-right" title="Support" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023 InnoPhase IoT, Inc. | All Rights Reserved | Proprietary &amp; Confidential.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>